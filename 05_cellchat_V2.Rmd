---
title: "Examine cell-cell communication"
author: "Kent Riemondy RBI"
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "html") })
output:
  html_document:
    theme: yeti
    toc: true
    toc_float: true
    toc_depth: 3
    highlight: kate
    fig_caption: true
    code_folding: hide
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = FALSE, message = FALSE, warning = FALSE)
```


```{r, message = FALSE}
# source() function reads and executes the R code from the specified file
# The here() function constructs a path to the utils.R file by referencing the "src" directory within your project. It automatically determines the root directory of your project, making your code more portable and less reliant on hardcoded paths.

# source(here::here("src/utils.R"))
source(here::here(file.path("..", "..", "..", "src/utils.R")))
seed_value <- 20210805
```

# Load data

Need to extract out cell type annotations for tumor and myeloid, move to main object. Will
split data into individual samples then run cellchat individually. L<->R interactions
will be identified that are reproducibly in multiple samples.


```{r}
# so <- qread("objects/preprocessing/so_filtered_final_v2.qs")
so <- qread(file.path("..", "objects/preprocessing/so_filtered_final_v2.qs"))

# so_myl <- qread(file.path("immune", "objects", "so_myeloid.qs"))
# so_t <- qread(file.path("immune", "objects", "so_lym.qs"))
# so_gg <- qread(file.path("tumor", "objects", "so_tumor_gg2.qs"))
# so_pa <- qread(file.path("tumor", "objects", "so_tumor_pa2.qs"))
so_myl <- qread(file.path("..", "immune", "objects", "so_myeloid.qs"))
so_t <- qread(file.path("..", "immune", "objects", "so_lym.qs"))
so_gg <- qread(file.path("..", "tumor", "objects", "so_tumor_gg2.qs"))
so_pa <- qread(file.path("..", "tumor", "objects", "so_tumor_pa2.qs"))

myl_annots <- data.frame(
  cell = names(so_myl$simple_myl_cell_type),
  subpopulation = so_myl$simple_myl_cell_type,
  major_population = "myeloid")

t_annots <- data.frame(
  cell = names(so_t$simple_t_cell_type),
  subpopulation = so_t$simple_t_cell_type,
  major_population = "t")

pa_annots <- data.frame(
  cell = names(so_pa$pa_subpopulation),
  subpopulation = so_pa$pa_subpopulation,
  major_population = "pa")

gg_annots <- data.frame(
  cell = names(so_gg$gg_subpopulation),
  subpopulation = so_gg$gg_subpopulation,
  major_population = "gg")

remap_pa <- c(
  "NPC-like (VIM+ HOPX+ GFAP+)" = "AC-like-2",
  "Intermediate (ASCL1+ JUNB+ SOX3+)" = "OPC-like",
  "Differentiatied (MOG+ PLP1+)" = "OC-like-1",
  "TNC+ FOXD3+" = "OC-like-2",
  "MAPKhi" = "MAPKhi",
  "PCDHG+" = "AC-like-1",
  "1171-specific" = "1171-specific",
  "Hypoxic (VEGFA+ ADM+ ENO1+)" = "Hypoxic",
  "1459-specific (SIX1/6+)" = "1459-specific"
)

remap_gg <- c(
  "Astrocyte? AQP1/4+ CLU+"  = "AC-like-1",
  "PDGFRA+ Cell-cycle arrest (CDKN1/2+)" = "Glycolysis_hi",
  "Olig (mature)" = "OC-like",
  "PDGFRA+" = "OPC-like",
  "PDGFRA+ PCDHGA+" = "AC-like-2",
  "Neuron? (RBFOX3+ ZIC1+ BOC+ STMN2+)" = "Ribosome_hi",
  "Neuron? (STMN1+ GABRG2+ CHGA/B+ EOMES+)" = "Neuron-like"
)

pa_annots$subpopulation <- remap_pa[pa_annots$subpopulation]
gg_annots$subpopulation <- remap_gg[gg_annots$subpopulation]

subpopulation_annots <- rbind(pa_annots, gg_annots, myl_annots, t_annots)

so <- so[, colnames(so) %in% subpopulation_annots$cell]
idx <- match(colnames(so), subpopulation_annots$cell)

so@meta.data <- cbind(so@meta.data,
                      subpopulation_annots[idx, c("subpopulation", "major_population")])

```

```{r}
pa <- so[, so$Dx == "pilocytic astrocytoma"]
gg <- so[, so$Dx == "ganglioglioma"]
```

## CellChat

```{r}
library(CellChat) # devtools::install_github("jinworks/CellChat")
library(patchwork)
# dir.create("objects/cellchat")
dir.create("objects/cellchat", recursive = TRUE)

objs <- c("objects/cellchat/cell-chat-ggs.rds", 
          "objects/cellchat/cell-chat-pas.rds")

if(!all(file.exists(objs))) {
  CellChatDB <- CellChatDB.human
  ## Change: Want to analyze all the pathways in CellChat without filtering for specific types:
  # CellChatDB.use <- subsetDB(CellChatDB, 
  #                            search = c("Secreted Signaling","ECM-Receptor")) 
  
  run_cellchat <- function(x, grp = "subpopulation") {
    cellchat <- createCellChat(object = x,
                               group.by = grp,
                               assay = "RNA")
    # cellchat@DB <- CellChatDB.use
    cellchat@DB <- CellChatDB
    
    cellchat <- subsetData(cellchat) |>
      identifyOverExpressedGenes() |>
      identifyOverExpressedInteractions() |>
      computeCommunProb(type = "triMean") |>
      # This function calculates the communication probability between cells based on the identified overexpressed genes and interactions. The type = "triMean" option computes the average of the communication probabilities across different conditions or replicates.
      filterCommunication(min.cells = 10) |>
      computeCommunProbPathway() |>
      # This function computes communication probabilities for specific signaling pathways
      aggregateNet() |>
      # This step aggregates the communication probabilities across the identified pathways to summarize the network of interactions.
      netAnalysis_computeCentrality(slot.name = "netP")  
      # This function calculates centrality measures (e.g., degree, betweenness) for the network, which can help identify key signaling hubs or important cell types in communication.
    
    df.net <- subsetCommunication(cellchat)
    list(ccobj = cellchat, 
         df = df.net)
  }
  
  pa_ccs <- lapply(SplitObject(pa, "UPN"), run_cellchat)
  saveRDS(pa_ccs, "objects/cellchat/cell-chat-pas.rds")
  
  gg_ccs <- lapply(SplitObject(gg, "UPN"), run_cellchat)
  saveRDS(gg_ccs, "objects/cellchat/cell-chat-ggs.rds")
} else {
  pa_ccs <- readRDS(objs[1])
  gg_ccs <- readRDS(objs[2])
}

tumor_subpops <- c(pa_annots$subpopulation, gg_annots$subpopulation)  |>
  as.character()
myeloid_pops <- as.character(myl_annots$subpopulation)

pa_res <- lapply(pa_ccs, "[[", "df") |> rbindlist(idcol = "UPN")
gg_res <- lapply(gg_ccs, "[[", "df") |> rbindlist(idcol = "UPN")
```

## Subset to myeloid <-> tumor interactions

```{r}
idx <- (pa_res$source %in% tumor_subpops & pa_res$target %in% myeloid_pops) | 
  (pa_res$source %in% myeloid_pops & pa_res$target %in% tumor_subpops) 
  
pa_myl_t <- pa_res[idx, ]
setDT(pa_myl_t)
pa_myl_t[, n_tumors := .N, by = .(source, target, interaction_name)]
pa_myl_t <- pa_myl_t[n_tumors >= 2]
pa_myl_t[, 
         mean_communication_prob := mean(prob),
         by = .(source, target, interaction_name)]

to_keep <- setdiff(colnames(pa_myl_t), c("UPN", "pval", "prob"))
pa_myl_t <- pa_myl_t[, ..to_keep] |> unique()

pa_myl_t <- pa_myl_t[order(source, target, -mean_communication_prob), ]
pa_myl_t
```

```{r}
idx <- (gg_res$source %in% tumor_subpops & gg_res$target %in% myeloid_pops) | 
  (gg_res$source %in% myeloid_pops & gg_res$target %in% tumor_subpops) 
  
gg_myl_t <- gg_res[idx, ]
setDT(gg_myl_t)
gg_myl_t[, n_tumors := .N, by = .(source, target, interaction_name)]
gg_myl_t <- gg_myl_t[n_tumors >= 2]
gg_myl_t[, 
         mean_communication_prob := mean(prob),
         by = .(source, target, interaction_name)]

to_keep <- setdiff(colnames(gg_myl_t), c("UPN", "pval", "prob"))
gg_myl_t <- gg_myl_t[, ..to_keep] |> unique()
gg_myl_t <- gg_myl_t[order(source, target, -mean_communication_prob), ]
gg_myl_t
```

# Change Some Names

```{r}
# Add: Change some info as Shadi asked
pa_myl_t_updated <- pa_myl_t
pa_myl_t_updated
```

```{r}
# Apply the necessary substitutions to the 'source' column
pa_myl_t_updated$source <- gsub("P2R712\\+", "P2RY12\\+", pa_myl_t_updated$source)
pa_myl_t_updated$source <- gsub("Myeloid \\(CCL3\\+\\)", "Myeloid-Chemokine", pa_myl_t_updated$source)
pa_myl_t_updated$source <- gsub("Chemokine \\(CCL3\\+\\)", "Myeloid-undefined", pa_myl_t_updated$source)

# Apply the necessary substitutions to the 'target' column
pa_myl_t_updated$target <- gsub("P2R712\\+", "P2RY12\\+", pa_myl_t_updated$target)
pa_myl_t_updated$target <- gsub("Myeloid \\(CCL3\\+\\)", "Myeloid-Chemokine", pa_myl_t_updated$target)
pa_myl_t_updated$target <- gsub("Chemokine \\(CCL3\\+\\)", "Myeloid-undefined", pa_myl_t_updated$target)

pa_myl_t_updated
```

```{r}
# Add: Change some info as Shadi asked
gg_myl_t_updated <- gg_myl_t
gg_myl_t_updated
```

```{r}
# Apply the necessary substitutions to the 'source' column
gg_myl_t_updated$source <- gsub("P2R712\\+", "P2RY12\\+", gg_myl_t_updated$source)
gg_myl_t_updated$source <- gsub("Myeloid \\(CCL3\\+\\)", "Myeloid-Chemokine", gg_myl_t_updated$source)
gg_myl_t_updated$source <- gsub("Chemokine \\(CCL3\\+\\)", "Myeloid-undefined", gg_myl_t_updated$source)

# Apply the necessary substitutions to the 'target' column
gg_myl_t_updated$target <- gsub("P2R712\\+", "P2RY12\\+", gg_myl_t_updated$target)
gg_myl_t_updated$target <- gsub("Myeloid \\(CCL3\\+\\)", "Myeloid-Chemokine", gg_myl_t_updated$target)
gg_myl_t_updated$target <- gsub("Chemokine \\(CCL3\\+\\)", "Myeloid-undefined", gg_myl_t_updated$target)


gg_myl_t_updated
```

# SAVE POINT

```{r}
Tian_work = paste0("./Tian_work")

if(!exists(Tian_work)){
  dir.create(Tian_work, recursive = TRUE)
}
```

```{r}
# preamble <- openxlsx::read.xlsx("tables/readme_myeloid_tumor_interactions.xlsx", colNames = FALSE)
preamble <- openxlsx::read.xlsx(file.path("..", "tables/readme_myeloid_tumor_interactions.xlsx"), colNames = FALSE)

colnames(preamble) <- c("column", "info")
# openxlsx::write.xlsx(list("README" = preamble, "PA" = pa_myl_t, "GG" = gg_myl_t), 
openxlsx::write.xlsx(list("README" = preamble, "PA" = pa_myl_t_updated, "GG" = gg_myl_t_updated), 
                    # file.path("..", "tables/myeloid_tumor_interactions.xlsx"),
                    file.path(Tian_work, "/myeloid_tumor_interactions_updated_labels_without_subset_final.xlsx"),
                    overwrite = TRUE)
```

```{r}
# Add: also send Shadi this table

CellChatDB <- CellChatDB.human
# # Change: Want to analyze all the pathways in CellChat without filtering for specific types:
# CellChatDB.use <- subsetDB(CellChatDB,
#                            search = c("Secreted Signaling","ECM-Receptor"))
#   

interaction_table <- CellChatDB$interaction
interaction_table

write.csv(interaction_table, file.path(Tian_work, "/interaction_table.csv"), row.names = FALSE)
```

# Chord Plot

```{r}
Chord_plot = paste0(Tian_work, "/Chord_plot")

if(!exists(Chord_plot)){
  dir.create(Chord_plot, recursive = TRUE)
}
```

```{r}
# Load the data with cell type information, separating Tumor and Immune
library(openxlsx)

file_path <- file.path("Tian_work/myeloid_tumor_interactions_updated_labels_without_subset_final_cell_type_added.xlsx")

pa_celltype_data <- read.xlsx(file_path, sheet = "PA", colNames = TRUE)
gg_celltype_data <- read.xlsx(file_path, sheet = "GG", colNames = TRUE)
```

## PA

```{r}
# Perfect 1.1: Source and Target of PA, separating tumor and immune

set.seed(99)

library(circlize)

# Define the list of pathways you want to plot
pathways <- c("MIF", "CCL", "PTN")

# Loop through each pathway and create a chord plot
for (pathway in pathways) {
  
  # Subset the data for the current pathway
  pa_pathway_data <- subset(pa_celltype_data, pathway_name == pathway)
  
  # Create a matrix for the chord plot
  interaction_matrix <- as.matrix(xtabs(mean_communication_prob ~ source + target, data = pa_pathway_data))
  
  # Prepare the grouping information
  source_groups <- pa_pathway_data %>%
    distinct(source, cell_type_source) %>%
    deframe() # Convert to named vector
  
  target_groups <- pa_pathway_data %>%
    distinct(target, cell_type_target) %>%
    deframe() # Convert to named vector
  
  # Merge both vectors into a single named vector
  all_groups <- c(source_groups, target_groups)

  # Clear previous settings to reset the plotting environment
  circos.clear()

  # Set up the parameters to shrink the canvas
  circos.par(canvas.xlim = c(-1.6, 1.6), canvas.ylim = c(-1.6, 1.6))

  # # Open a PDF file to save the plot for the current pathway
  # pdf(paste0(Chord_plot, "/PA_chord_plot_", pathway, "_pathway_ST.pdf"), width = 10, height = 10)
  png_path <- paste0(Chord_plot, "/PA_chord_plot_", pathway, "_pathway_ST.png")
  png(png_path, width = 8, height = 8, units = "in", res = 300) # 300 DPI

  # Draw the chord plot
  chordDiagram(interaction_matrix, 
               transparency = 0.5, 
               directional = 1, # Or directional = TRUE
               # the arrows point from the source cell type to the target cell type, indicating the direction of signaling.
               annotationTrack = c("grid"), 
               preAllocateTracks = list(track.height = 0.05),
               direction.type = c("diffHeight", "arrows"),
               link.arr.type = "big.arrow",
               group = all_groups)
  
  # Customize text to only show vertical labels
  circos.track(track.index = 1, panel.fun = function(x, y) {
      circos.text(CELL_META$xcenter, CELL_META$ylim[1], CELL_META$sector.index, 
          facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
  }, bg.border = NA) # Set bg.border to NA to remove border
  
  # Add a title to the plot
  title(paste("PA Chord Plot of", pathway, "Pathway - Source and Target"))
  
  dev.off()
}
```

```{r}
# Perfect 1.2: Ligand and Receptor of PA, separating tumor and immune

set.seed(99)

library(circlize)

# Define the list of pathways you want to plot
pathways <- c("MIF", "CCL", "PTN")

# Loop through each pathway and create a chord plot
for (pathway in pathways) {
  
  # Subset the data for the current pathway
  pa_pathway_data <- subset(pa_celltype_data, pathway_name == pathway)
  
  # Create a matrix for the chord plot
  interaction_matrix <- as.matrix(xtabs(mean_communication_prob ~ ligand + receptor, data = pa_pathway_data))
  
  # Prepare the grouping information
  ligand_groups <- pa_pathway_data %>%
    distinct(ligand, cell_type_source) %>%
    deframe() # Convert to named vector
  
  receptor_groups <- pa_pathway_data %>%
    distinct(receptor, cell_type_target) %>%
    deframe() # Convert to named vector
  
  # Merge both vectors into a single named vector
  all_groups <- c(ligand_groups, receptor_groups)

  # Clear previous settings to reset the plotting environment
  circos.clear()

  # Set up the parameters to shrink the canvas
  circos.par(canvas.xlim = c(-1.6, 1.6), canvas.ylim = c(-1.6, 1.6))

  # # Open a PDF file to save the plot for the current pathway
  # pdf(paste0(Chord_plot, "/PA_chord_plot_", pathway, "_pathway_LR.pdf"), width = 10, height = 10)
  png_path <- paste0(Chord_plot, "/PA_chord_plot_", pathway, "_pathway_LR.png")
  png(png_path, width = 8, height = 8, units = "in", res = 300) # 300 DPI

  # Draw the chord plot
  chordDiagram(interaction_matrix, 
               transparency = 0.5, 
               directional = 1, # Or directional = TRUE
               # the arrows point from the source cell type to the target cell type, indicating the direction of signaling.
               annotationTrack = c("grid"), 
               preAllocateTracks = list(track.height = 0.05),
               direction.type = c("arrows"),
               link.arr.type = "big.arrow",
               group = all_groups)
  
  # Customize text to only show vertical labels
  circos.track(track.index = 1, panel.fun = function(x, y) {
      circos.text(CELL_META$xcenter, CELL_META$ylim[1], CELL_META$sector.index, 
          facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
  }, bg.border = NA) # Set bg.border to NA to remove border
  
  # Add a title to the plot
  title(paste("PA Chord Plot of", pathway, "Pathway - Ligand and Receptor"))
  
  # Close the PDF device
  dev.off()
}
```

```{r}
# Perfect 1.3: Put two figures together

library(magick)

# Define the list of pathways you want to plot
pathways <- c("MIF", "CCL", "PTN")

# Loop through each pathway and create and combine two plots
for (pathway in pathways) {
  # # Use magick to combine the saved PDFs (you can also use PNGs if preferred)
  # plot_st <- image_read(paste0(Chord_plot, "/PA_chord_plot_", pathway, "_pathway_ST.png"))
  # plot_lr <- image_read(paste0(Chord_plot, "/PA_chord_plot_", pathway, "_pathway_LR.png"))
  # 
  # # Combine the images side by side
  # combined_plot <- image_append(c(plot_st, plot_lr))
  # 
  # # Save the combined image as a PDF
  # image_write(combined_plot, paste0(Chord_plot, "/PA_chord_plot_", pathway, "_combined.pdf"))
  
  # Read both saved plots using magick
  img1 <- image_read(paste0(Chord_plot, "/PA_chord_plot_", pathway, "_pathway_ST.png"))
  img2 <- image_read(paste0(Chord_plot, "/PA_chord_plot_", pathway, "_pathway_LR.png"))

  # Combine the images side by side
  combined_img <- image_append(c(img1, img2))

  # Save the combined image as a high-resolution PNG
  combined_png_path <- paste0(Chord_plot, "/PA_chord_plot_", pathway, "_combined.png")
  image_write(combined_img, combined_png_path)
}
```

```{r}
# Perfect 2.1: Source and Target of PA, separating tumor and immune, adding ligand and receptor rectangles

set.seed(99)

library(circlize)
library(dplyr)

# Define the list of pathways you want to plot
pathways <- c("MIF", "CCL", "PTN")

# Loop through each pathway and create a chord plot
for (pathway in pathways) {
  
  # Subset the data for the current pathway
  pa_pathway_data <- subset(pa_celltype_data, pathway_name == pathway)
  
  # Create a matrix for the chord plot
  interaction_matrix <- as.matrix(xtabs(mean_communication_prob ~ source + target, data = pa_pathway_data))
  
  # Prepare the grouping information
  source_groups <- pa_pathway_data %>%
    distinct(source, cell_type_source) %>%
    deframe() # Convert to named vector
  
  target_groups <- pa_pathway_data %>%
    distinct(target, cell_type_target) %>%
    deframe() # Convert to named vector
  
  # Merge both vectors into a single named vector
  all_groups <- c(source_groups, target_groups)

  # Define unique ligands and receptors
  unique_ligands <- unique(pa_pathway_data$ligand)
  unique_receptors <- unique(pa_pathway_data$receptor)

  # Generate distinct colors for ligands
  ligand_colors <- setNames(rainbow(length(unique_ligands), start = 0.2, end = 0.5), unique_ligands)
  # Generate distinct colors for receptors
  receptor_colors <- setNames(rainbow(length(unique_receptors), start = 0.6, end = 0.9), unique_receptors)

  # Clear previous settings to reset the plotting environment
  circos.clear()

  # Set up the parameters to shrink the canvas
  circos.par(canvas.xlim = c(-1.7, 1.7), canvas.ylim = c(-1.7, 1.7))

  # # Open a PDF file to save the plot for the current pathway
  pdf(paste0(Chord_plot, "/PA_chord_plot_", pathway, "_pathway_combined.pdf"), width = 10, height = 10)
  
  # Draw the chord plot
  chordDiagram(interaction_matrix, 
               transparency = 0.5, 
               directional = TRUE, # Or directional = 1
               # the arrows point from the source cell type to the target cell type, indicating the direction of signaling.
               annotationTrack = c("grid"), 
               preAllocateTracks = list(track.height = 0.1),
               direction.type = c("diffHeight", "arrows"),
               link.arr.type = "big.arrow",
               group = all_groups)
  
  # Add ligand and receptor rectangles using circos.rect
  # Fetch sector-specific ylim
  ylim <- get.cell.meta.data("ylim", track.index = 1)

  for (i in seq_len(nrow(pa_pathway_data))) {
    # Extract sector information
    current_source <- pa_pathway_data$source[i]
    current_target <- pa_pathway_data$target[i]
    current_ligand <- pa_pathway_data$ligand[i]
    current_receptor <- pa_pathway_data$receptor[i]
  
    # Y ranges for ligands and receptors
    ligand_y1 <- ylim[1] + (ylim[2] - ylim[1]) * 0.2
    receptor_y1 <- ylim[1] + (ylim[2] - ylim[1]) * 0.5
     
    # Ligand rectangle
    circos.rect(
      xleft = get.cell.meta.data("xlim", sector.index = current_source)[1],
      xright = get.cell.meta.data("xlim", sector.index = current_source)[2],
      ybottom = ligand_y1,
      ytop = ligand_y1 + 0.2,
      col = ligand_colors[current_ligand],
      border = ligand_colors[current_ligand],
      sector.index = current_source,
      track.index = 1
    )
  
    # Receptor rectangle
    circos.rect(
      xleft = get.cell.meta.data("xlim", sector.index = current_target)[1],
      xright = get.cell.meta.data("xlim", sector.index = current_target)[2],
      ybottom = receptor_y1,
      ytop = receptor_y1 + 0.2,
      col = receptor_colors[current_receptor],
      border = receptor_colors[current_receptor],
      sector.index = current_target,
      track.index = 1
    )
  }
  
  # Display legends at the top-right corner
  par(mar = c(1, 1, 1, 1))
  
  # Combine ligand and receptor legends
  legend(
    "topright", 
    inset = c(0, 0.1), 
    legend = c("Ligands", names(ligand_colors), "", "Receptors", names(receptor_colors)),  # Add a blank line ("") for spacing
    col = c(NA, ligand_colors, NA, NA, receptor_colors),  # NA for titles and spacing
    pch = c(NA, rep(15, length(ligand_colors)), NA, NA, rep(15, length(receptor_colors))),  # NA for titles and spacing
    cex = 0.8,
    bty = "n",
    title = NULL, # No separate title
    xpd = TRUE
  )

  # Customize text to show source and target names as vertical labels, with more distance from the circle
  circos.track(track.index = 1, panel.fun = function(x, y) {
      # Adjust the y position to move the text further from the circle (by adding some factor)
      circos.text(CELL_META$xcenter, CELL_META$ylim[2] + 0.05, CELL_META$sector.index,
          facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
  }, bg.border = NA)
  
  # Add a title to the plot
  title(paste("PA Chord Plot of", pathway, "Pathway - Source and Target (with ligand and receptor showed in legend)"))
  
  dev.off()
}
```

```{r}
# Tested 2: for separate tumor and immune, with ligand and receptor rectangles and legends
library(circlize)
library(dplyr)

# Subset the data for the "MIF" pathway
pa_pathway_data <- subset(pa_celltype_data, pathway_name == "MIF")

# Create a matrix for the chord plot
interaction_matrix <- as.matrix(xtabs(mean_communication_prob ~ source + target, data = pa_pathway_data))

# Prepare the grouping information
source_groups <- pa_pathway_data %>%
  distinct(source, cell_type_source) %>%
  deframe() # Convert to named vector

target_groups <- pa_pathway_data %>%
  distinct(target, cell_type_target) %>%
  deframe() # Convert to named vector

# Merge both vectors into a single named vector
all_groups <- c(source_groups, target_groups)

# Define unique ligands and receptors
unique_ligands <- unique(pa_pathway_data$ligand)
unique_receptors <- unique(pa_pathway_data$receptor)

# Create color mappings
ligand_colors <- setNames(rainbow(length(unique_ligands), start = 0.2), unique_ligands)
receptor_colors <- setNames(rainbow(length(unique_receptors), start = 0.5), unique_receptors)

# Clear previous settings to reset the plotting environment
circos.clear()

# Set up the parameters to shrink the canvas
circos.par(canvas.xlim = c(-1.5, 1.5), canvas.ylim = c(-1.5, 1.5))

pdf(paste0(Chord_plot, "/aaaPA_chord_plot_", "MIF", "_pathway.pdf"), width = 10, height = 10)

# Draw the chord plot with grouping
chordDiagram(
  interaction_matrix,
  transparency = 0.5,
  directional = TRUE,
  annotationTrack = c("grid"),
  preAllocateTracks = list(track.height = 0.1),
  direction.type = c("diffHeight", "arrows"),
  link.arr.type = "big.arrow",
  group = all_groups
)

# Add ligand and receptor rectangles using circos.rect
# Fetch sector-specific ylim
ylim <- get.cell.meta.data("ylim", track.index = 1)

for (i in seq_len(nrow(pa_pathway_data))) {
  # Extract sector information
  current_source <- pa_pathway_data$source[i]
  current_target <- pa_pathway_data$target[i]
  current_ligand <- pa_pathway_data$ligand[i]
  current_receptor <- pa_pathway_data$receptor[i]

  # Y ranges for ligands and receptors
  ligand_y1 <- ylim[1] + (ylim[2] - ylim[1]) * 0.2
  receptor_y1 <- ylim[1] + (ylim[2] - ylim[1]) * 0.5
   
  # Ligand rectangle
  circos.rect(
    xleft = get.cell.meta.data("xlim", sector.index = current_source)[1],
    xright = get.cell.meta.data("xlim", sector.index = current_source)[2],
    ybottom = ligand_y1,
    ytop = ligand_y1 + 0.2,
    col = ligand_colors[current_ligand],
    border = ligand_colors[current_ligand],
    sector.index = current_source,
    track.index = 1
  )

  # Receptor rectangle
  circos.rect(
    # xleft = CELL_META$xlim[1],
    # xright = CELL_META$xlim[2],
    xleft = get.cell.meta.data("xlim", sector.index = current_target)[1],
    xright = get.cell.meta.data("xlim", sector.index = current_target)[2],
    ybottom = receptor_y1,
    ytop = receptor_y1 + 0.2,
    col = receptor_colors[current_receptor],
    border = receptor_colors[current_receptor],
    sector.index = current_target,
    track.index = 1
  )
}

# Ligand and Receptor legends at top-right corner
# Display legends at the top-right corner
par(mar = c(1, 1, 1, 1))

# Combine ligand and receptor legends
legend(
  "topleft", # Place at the top-left corner
  inset = c(0, 0.1), 
  legend = c("Ligands", names(ligand_colors), "", "Receptors", names(receptor_colors)),  # Add a blank line ("") for spacing
  col = c(NA, ligand_colors, NA, NA, receptor_colors),  # NA for titles and spacing
  pch = c(NA, rep(15, length(ligand_colors)), NA, NA, rep(15, length(receptor_colors))),  # NA for titles and spacing
  cex = 0.8,
  bty = "n",
  title = NULL, # No separate title
  xpd = TRUE
)

# Customize text to show source and target names as vertical labels, with more distance from the circle
circos.track(track.index = 1, panel.fun = function(x, y) {
    # Adjust the y position to move the text further from the circle (by adding some factor)
    circos.text(CELL_META$xcenter, CELL_META$ylim[2] + 0.05, CELL_META$sector.index,
        facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
}, bg.border = NA)

# Add a title to the plot
title("Clustered Chord Plot of MIF Signaling Pathway with Ligand/Receptor Rectangles")

# Close the PDF device
dev.off()

```

```{r}
# Tested 1: for separate tumor and immune

library(circlize)
library(dplyr)

# Subset the data for the "MIF" pathway
pa_pathway_data <- subset(pa_celltype_data, pathway_name == "MIF")

# Create a matrix for the chord plot
interaction_matrix <- as.matrix(xtabs(mean_communication_prob ~ source + target, data = pa_pathway_data))

# Prepare the grouping information
source_groups <- pa_pathway_data %>%
  distinct(source, cell_type_source) %>%
  deframe() # Convert to named vector

target_groups <- pa_pathway_data %>%
  distinct(target, cell_type_target) %>%
  deframe() # Convert to named vector

# Merge both vectors into a single named vector
all_groups <- c(source_groups, target_groups)

# Clear previous settings to reset the plotting environment
circos.clear()

# Set up the parameters to shrink the canvas
circos.par(canvas.xlim = c(-1.5, 1.5), canvas.ylim = c(-1.5, 1.5))

# Draw the chord plot with grouping
chordDiagram(interaction_matrix,
             transparency = 0.5,
             directional = TRUE,
             annotationTrack = c("grid"),
             preAllocateTracks = list(track.height = 0.05),
             direction.type = c("diffHeight", "arrows"),
             link.arr.type = "big.arrow",
             group = all_groups)  # Use the grouping info

# # Customize text to only show vertical labels
# circos.track(track.index = 1, panel.fun = function(x, y) {
#     circos.text(CELL_META$xcenter, CELL_META$ylim[1], CELL_META$sector.index,
#         facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
# }, bg.border = NA)

# Add a title to the plot
title("Clustered Chord Plot of MIF Signaling Pathway")

# Clear the plotting environment for future plots
circos.clear()

```

## GG

```{r}
# Perfect 1.1: Source and Target of GG, separating tumor and immune

set.seed(99)

library(circlize)

# Define the list of pathways you want to plot
pathways <- c("MIF", "PTN")

# Loop through each pathway and create a chord plot
for (pathway in pathways) {
  
  # Subset the data for the current pathway
  gg_pathway_data <- subset(gg_celltype_data, pathway_name == pathway)
  
  # Create a matrix for the chord plot
  interaction_matrix <- as.matrix(xtabs(mean_communication_prob ~ source + target, data = gg_pathway_data))
  
  # Prepare the grouping information
  source_groups <- gg_pathway_data %>%
    distinct(source, cell_type_source) %>%
    deframe() # Convert to named vector
  
  target_groups <- gg_pathway_data %>%
    distinct(target, cell_type_target) %>%
    deframe() # Convert to named vector
  
  # Merge both vectors into a single named vector
  all_groups <- c(source_groups, target_groups)
  
  # Clear previous settings to reset the plotting environment
  circos.clear()
  
  # Set up the parameters to shrink the canvas
  circos.par(canvas.xlim = c(-1.6, 1.6), canvas.ylim = c(-1.6, 1.6))

  # Open a PDF file to save the plot for the current pathway
  # pdf(paste0(Chord_plot, "/GG_chord_plot_", pathway, "_pathway_ST.pdf"), width = 10, height = 10)
  png_path <- paste0(Chord_plot, "/GG_chord_plot_", pathway, "_pathway_ST.png")
  png(png_path, width = 8, height = 8, units = "in", res = 300) # 300 DPI

  # Draw the chord plot
  chordDiagram(interaction_matrix, 
               transparency = 0.5, 
               directional = TRUE, # Or directional = 1
               annotationTrack = c("grid"), 
               preAllocateTracks = list(track.height = 0.05),
               direction.type = c("diffHeight", "arrows"),
               link.arr.type = "big.arrow",
               group = all_groups)
  
  # Customize text to only show vertical labels
  circos.track(track.index = 1, panel.fun = function(x, y) {
      circos.text(CELL_META$xcenter, CELL_META$ylim[1], CELL_META$sector.index, 
          facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))  # Adjust cex to make labels smaller
  }, bg.border = NA) # Set bg.border to NA to remove border
  
  # Add a title to the plot
  title(paste("GG Chord Plot of", pathway, "Pathway - Source and Target"))
  
  # Close the PDF device
  dev.off()
}
```

```{r}
# Perfect 1.2: Ligand and Receptor of GG, separating tumor and immune

set.seed(99)

library(circlize)

# Define the list of pathways you want to plot
pathways <- c("MIF", "PTN")

# Loop through each pathway and create a chord plot
for (pathway in pathways) {
  
  # Subset the data for the current pathway
  gg_pathway_data <- subset(gg_celltype_data, pathway_name == pathway)
  
  # Create a matrix for the chord plot
  interaction_matrix <- as.matrix(xtabs(mean_communication_prob ~ ligand + receptor, data = gg_pathway_data))
  
  # Prepare the grouping information
  ligand_groups <- gg_pathway_data %>%
    distinct(ligand, cell_type_source) %>%
    deframe() # Convert to named vector
  
  receptor_groups <- gg_pathway_data %>%
    distinct(receptor, cell_type_target) %>%
    deframe() # Convert to named vector
  
  # Merge both vectors into a single named vector
  all_groups <- c(ligand_groups, receptor_groups)
  
  # Clear previous settings to reset the plotting environment
  circos.clear()
  
  # Set up the parameters to shrink the canvas
  circos.par(canvas.xlim = c(-1.6, 1.6), canvas.ylim = c(-1.6, 1.6))

  # Open a PDF file to save the plot for the current pathway
  # pdf(paste0(Chord_plot, "/GG_chord_plot_", pathway, "_pathway_LR.pdf"), width = 10, height = 10)
  png_path <- paste0(Chord_plot, "/GG_chord_plot_", pathway, "_pathway_LR.png")
  png(png_path, width = 8, height = 8, units = "in", res = 300) # 300 DPI

  # Draw the chord plot
  chordDiagram(interaction_matrix, 
               transparency = 0.5, 
               directional = TRUE, # Or directional = 1
               annotationTrack = c("grid"), 
               preAllocateTracks = list(track.height = 0.05),
               direction.type = c("arrows"),
               link.arr.type = "big.arrow",
               group = all_groups)
  
  # Customize text to only show vertical labels
  circos.track(track.index = 1, panel.fun = function(x, y) {
      circos.text(CELL_META$xcenter, CELL_META$ylim[1], CELL_META$sector.index, 
          facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))  # Adjust cex to make labels smaller
  }, bg.border = NA) # Set bg.border to NA to remove border
  
  # Add a title to the plot
  title(paste("GG Chord Plot of", pathway, "Pathway - Ligand and Receptor"))
  
  # Close the PDF device
  dev.off()
}
```

```{r}
# Perfect 1.3: Put two figures together

library(magick)

# Define the list of pathways you want to plot
pathways <- c("MIF", "PTN")

# Loop through each pathway and create and combine two plots
for (pathway in pathways) {
  # Read both saved plots using magick
  img1 <- image_read(paste0(Chord_plot, "/GG_chord_plot_", pathway, "_pathway_ST.png"))
  img2 <- image_read(paste0(Chord_plot, "/GG_chord_plot_", pathway, "_pathway_LR.png"))

  # Combine the images side by side
  combined_img <- image_append(c(img1, img2))

  # Save the combined image as a high-resolution PNG
  combined_png_path <- paste0(Chord_plot, "/GG_chord_plot_", pathway, "_combined.png")
  image_write(combined_img, combined_png_path)
}
```

```{r}
# Perfect 2.1: Source and Target of PA, separating tumor and immune, adding ligand and receptor rectangles

set.seed(99)

library(circlize)
library(dplyr)

# Define the list of pathways you want to plot
pathways <- c("MIF", "PTN")

# Loop through each pathway and create a chord plot
for (pathway in pathways) {
  
  # Subset the data for the current pathway
  gg_pathway_data <- subset(gg_celltype_data, pathway_name == pathway)
  
  # Create a matrix for the chord plot
  interaction_matrix <- as.matrix(xtabs(mean_communication_prob ~ source + target, data = gg_pathway_data))
  
  # Prepare the grouping information
  source_groups <- gg_pathway_data %>%
    distinct(source, cell_type_source) %>%
    deframe() # Convert to named vector
  
  target_groups <- gg_pathway_data %>%
    distinct(target, cell_type_target) %>%
    deframe() # Convert to named vector
  
  # Merge both vectors into a single named vector
  all_groups <- c(source_groups, target_groups)

  # Define unique ligands and receptors
  unique_ligands <- unique(gg_pathway_data$ligand)
  unique_receptors <- unique(gg_pathway_data$receptor)

  # Generate distinct colors for ligands
  ligand_colors <- setNames(rainbow(length(unique_ligands), start = 0.2, end = 0.5), unique_ligands)
  # Generate distinct colors for receptors
  receptor_colors <- setNames(rainbow(length(unique_receptors), start = 0.6, end = 0.9), unique_receptors)

  # Clear previous settings to reset the plotting environment
  circos.clear()

  # Set up the parameters to shrink the canvas
  circos.par(canvas.xlim = c(-1.7, 1.7), canvas.ylim = c(-1.7, 1.7))

  # # Open a PDF file to save the plot for the current pathway
  pdf(paste0(Chord_plot, "/GG_chord_plot_", pathway, "_pathway_combined.pdf"), width = 10, height = 10)
  
  # Draw the chord plot
  chordDiagram(interaction_matrix, 
               transparency = 0.5, 
               directional = TRUE, # Or directional = 1
               # the arrows point from the source cell type to the target cell type, indicating the direction of signaling.
               annotationTrack = c("grid"), 
               preAllocateTracks = list(track.height = 0.1),
               direction.type = c("diffHeight", "arrows"),
               link.arr.type = "big.arrow",
               group = all_groups)
  
  # Add ligand and receptor rectangles using circos.rect
  # Fetch sector-specific ylim
  ylim <- get.cell.meta.data("ylim", track.index = 1)

  for (i in seq_len(nrow(gg_pathway_data))) {
    # Extract sector information
    current_source <- gg_pathway_data$source[i]
    current_target <- gg_pathway_data$target[i]
    current_ligand <- gg_pathway_data$ligand[i]
    current_receptor <- gg_pathway_data$receptor[i]
  
    # Y ranges for ligands and receptors
    ligand_y1 <- ylim[1] + (ylim[2] - ylim[1]) * 0.2
    receptor_y1 <- ylim[1] + (ylim[2] - ylim[1]) * 0.5
     
    # Ligand rectangle
    circos.rect(
      xleft = get.cell.meta.data("xlim", sector.index = current_source)[1],
      xright = get.cell.meta.data("xlim", sector.index = current_source)[2],
      ybottom = ligand_y1,
      ytop = ligand_y1 + 0.2,
      col = ligand_colors[current_ligand],
      border = ligand_colors[current_ligand],
      sector.index = current_source,
      track.index = 1
    )
  
    # Receptor rectangle
    circos.rect(
      xleft = get.cell.meta.data("xlim", sector.index = current_target)[1],
      xright = get.cell.meta.data("xlim", sector.index = current_target)[2],
      ybottom = receptor_y1,
      ytop = receptor_y1 + 0.2,
      col = receptor_colors[current_receptor],
      border = receptor_colors[current_receptor],
      sector.index = current_target,
      track.index = 1
    )
  }
  
  # Display legends at the top-right corner
  par(mar = c(1, 1, 1, 1))
  
  # Combine ligand and receptor legends
  legend(
    "topright", 
    inset = c(0, 0.1), 
    legend = c("Ligands", names(ligand_colors), "", "Receptors", names(receptor_colors)),  # Add a blank line ("") for spacing
    col = c(NA, ligand_colors, NA, NA, receptor_colors),  # NA for titles and spacing
    pch = c(NA, rep(15, length(ligand_colors)), NA, NA, rep(15, length(receptor_colors))),  # NA for titles and spacing
    cex = 0.8,
    bty = "n",
    title = NULL, # No separate title
    xpd = TRUE
  )

  # Customize text to show source and target names as vertical labels, with more distance from the circle
  circos.track(track.index = 1, panel.fun = function(x, y) {
      # Adjust the y position to move the text further from the circle (by adding some factor)
      circos.text(CELL_META$xcenter, CELL_META$ylim[2] + 0.05, CELL_META$sector.index,
          facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
  }, bg.border = NA)
  
  # Add a title to the plot
  title(paste("GG Chord Plot of", pathway, "Pathway - Source and Target (with ligand and receptor showed in legend)"))
  
  dev.off()
}
```

# Kent's Method 

```{r}
Kent_res = paste0(Tian_work, "/Kent_res")

if(!exists(Kent_res)){
  dir.create(Kent_res, recursive = TRUE)
}
```

```{r}
Dot_plot = paste0(Kent_res, "/TopGenes_Dot_plot")

if(!exists(Dot_plot)){
  dir.create(Dot_plot, recursive = TRUE)
}
```

## PA-Tumor

### Top 10 Markers Dot Plot

```{r}
set.seed(99)

# Reference: from "tumor/pa.Rmd"
# Here use SingleCellExperiment Object
# The following is the process, you can also just load the markers files.

so_pa <- qread(file.path("..", "tumor", "objects", "so_tumor_pa2.qs"))

library(scran)
so_pa$Dx_simple <- ifelse(str_detect(so_pa$Dx, "low grade glioma"),
                       "low grade glioma",
                       so_pa$Dx)
# temporary fix for issue #4639
so_diet <- DietSeurat(so_pa, graphs = "pca")
sce <- as.SingleCellExperiment(so_diet)
rm(so_diet)

sce$pa_tumor_harmony_res.0.3 <- droplevels(sce$pa_tumor_harmony_res.0.3)
markers.cell_type.up <- findMarkers(sce,
                                groups = sce$pa_tumor_harmony_res.0.3,
                                block = sce$orig.ident, # control for batch effects or sample differences.
                                lfc = 0.5,
                                direction="up") %>%
  lapply(., as.data.frame) %>%
  map(~rownames_to_column(.x, "gene") %>%
        filter(FDR < 0.01))


# You can find the stored results from Kent's record.
# markers.cell_type.up %>%
#   bind_rows(.id = "cluster") %>%
#   write_tsv(file.path(mkrs_dir, "scran_pa_tumor_consensus_markers.tsv"))
# 
# map(markers.cell_type.up,
#     ~set_xlsx_class(.x, "gene", "Text")) %>%
# openxlsx::write.xlsx(., file.path(mkrs_dir, "scran_pa_tumor_consensus_markers.xlsx"),
#                      overwrite = TRUE)
```

```{r}
# # Deprecate: Each group is not the same value, so cannot use for the following REACTOME Analysis
# 
# mkrs <- get_marker_summaries(so_pa,
#                      "pa_tumor_harmony_res.0.3",
#                      outdir = mkrs_dir,
#                      min_pct = 10,
#                      prefix = "pa_harmony")
# 
# # Each group is not the same value, so cannot use for the following REACTOME Analysis
# topx <- mkrs$mkrs %>% 
#   filter(logFC > 0, padj < 0.05) %>% 
#   mutate(group = factor(group, levels = sort(unique(so_pa$pa_tumor_harmony_res.0.3)))) %>% 
#   group_by(group) %>% 
#   arrange(padj, desc(logFC), .by_group = TRUE) %>% 
#   count(group)
#   # dplyr::slice(1:10)
# 
# topx
```

```{r}
# Select the top 10 genes from each group and combine them into a single data frame
top_genes_df <- lapply(names(markers.cell_type.up), function(group) {
  markers.cell_type.up[[group]] %>%
    arrange(desc(summary.logFC)) %>%  # Sort by logFC in descending order
    head(10) %>%             # Select the top 5 genes
    mutate(group = group)    # Add a column to identify the group
}) %>%
  bind_rows() # Combine all groups into a single data frame

top_genes_df
```

```{r}
so_pa@meta.data
```

```{r}
plot_harmony(so_pa, "pa_tumor_harmony_res.0.3", legend_title = "harmony-clusters") 
```

```{r}
# Change the new labels
# cluster 0 = OC-like 1
# cluster 1 = OPC-like
# cluster 2 = AC-like 1
# cluster 3 = 1459-specific
# cluster 4 = MAPKhi
# cluster 5 = AC-like 2
# cluster 6 = Hypoxic
# cluster 7 = 1171-specific
# cluster 8 = OC-like 2

# Add the 'cell_type' column to the metadata using case_when
so_pa@meta.data <- so_pa@meta.data %>%
  mutate(cell_type = case_when(
    pa_tumor_harmony_res.0.3 == 0 ~ "OC-like",
    pa_tumor_harmony_res.0.3 == 1 ~ "OPC-like",
    pa_tumor_harmony_res.0.3 == 2 ~ "AC-like 1",
    pa_tumor_harmony_res.0.3 == 3 ~ "1459-specific",
    pa_tumor_harmony_res.0.3 == 4 ~ "MAPKhi",
    pa_tumor_harmony_res.0.3 == 5 ~ "AC-like 2",
    pa_tumor_harmony_res.0.3 == 6 ~ "Hypoxic",
    pa_tumor_harmony_res.0.3 == 7 ~ "1171-specific",
    pa_tumor_harmony_res.0.3 == 8 ~ "OC-like 2",
    TRUE ~ NA_character_  # Default case if no match is found
  ))

so_pa@meta.data
```

```{r}
plot_harmony(so_pa, "cell_type", legend_title = "Cell Type") 
```

```{r}
# Change the new labels
# cluster 0 = OC-like 1
# cluster 1 = OPC-like
# cluster 2 = AC-like 1
# cluster 3 = 1459-specific
# cluster 4 = MAPKhi
# cluster 5 = AC-like 2
# cluster 6 = Hypoxic
# cluster 7 = 1171-specific
# cluster 8 = OC-like 2

# Recode the cell_type column and set a custom order
top_genes_df <- top_genes_df %>%
  mutate(cell_type = recode(group,
                            `0` = "OC-like 1",
                            `1` = "OPC-like",
                            `2` = "AC-like 1",
                            `3` = "1459-specific",
                            `4` = "MAPKhi",
                            `5` = "AC-like 2",
                            `6` = "Hypoxic",
                            `7` = "1171-specific",
                            `8` = "OC-like 2"),
         cell_type = factor(cell_type, levels = c("OC-like 1", "OPC-like", "AC-like 1", 
                                                  "1459-specific", "MAPKhi", "AC-like 2", 
                                                  "Hypoxic", "1171-specific", "OC-like 2")))

top_genes_df
```

```{r}
# Ensure the gene order matches the original order in top_genes_df
top_genes_df <- top_genes_df %>%
  mutate(gene = factor(gene, levels = unique(gene)))

logFC_midpoint <- mean(top_genes_df$summary.logFC)  # Use the mean of logFC as midpoint

# Create the dot plot
dot_plot <- ggplot(top_genes_df, aes(x = cell_type, y = gene)) +
  geom_point(aes(size = -log10(FDR), color = summary.logFC)) +
  scale_color_gradient2(low = "blue", mid = "grey", high = "red", midpoint = logFC_midpoint) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
  ) +
  labs(color = "logFC", size = "-log10(FDR)")

dot_plot

# Specify the file path
output_file <- file.path(Dot_plot, "DotPlot_TopGenes_PA_Tumor.pdf")

ggsave(output_file, plot = dot_plot, width = 8, height = 10)
```

### REACTOME Analysis

```{r}
REACTOME_Analysis = paste0(Kent_res, "/REACTOME_Analysis")

if(!exists(REACTOME_Analysis)){
  dir.create(REACTOME_Analysis, recursive = TRUE)
}
```

```{r}
############# REACTOME pathway #############
#####gsePathway()

library(org.Hs.eg.db)
library(clusterProfiler)

sce$pa_tumor_harmony_res.0.3 <- droplevels(sce$pa_tumor_harmony_res.0.3)
# Without filter, use all markers.
markers.cell_type.up <- findMarkers(sce,
                                groups = sce$pa_tumor_harmony_res.0.3,
                                block = sce$orig.ident, # control for batch effects or sample differences.
                                lfc = 0.5,
                                direction="up") %>%
  lapply(., as.data.frame) %>%
  map(~rownames_to_column(.x, "gene") )

# lapply(markers.cell_type.up, colnames)

# Keep only the first five columns for each cluster
markers.cell_type.up <- lapply(markers.cell_type.up, function(df) {
  df[, c("gene", "Top", "p.value", "FDR", "summary.logFC")]
})

# Combine all clusters into a single data frame with the cluster information
markers.cell_type.up.df <- do.call(rbind, lapply(names(markers.cell_type.up), function(cluster) {
  cluster_markers <- markers.cell_type.up[[cluster]]
  cluster_markers$cluster <- cluster  # Add cluster information
  return(cluster_markers)
}))

# Reset row names for clarity
rownames(markers.cell_type.up.df) <- NULL

# Rank genes within each cluster based on summary.logFC (you can adjust the order if needed)
markers.cell_type.up.df <- markers.cell_type.up.df %>%
  group_by(cluster) %>%
  arrange(cluster, desc(summary.logFC)) %>%
  ungroup()

# Split the data by cluster and extract ranked gene names along with summary.logFC
cluster_gene_lists_all <- markers.cell_type.up.df %>%
  split(.$cluster) %>%
  lapply(function(x) {
    # Create a data frame with both Entrez ID and summary.logFC for each gene
    mapped_genes <- bitr(x$gene, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Hs.eg.db)
    
    # Merge the mapped Entrez ID with the summary.logFC values
    merged_data <- merge(mapped_genes, x[, c("gene", "summary.logFC")], by.x = "SYMBOL", by.y = "gene")
    
    # Sort based on summary.logFC
    merged_data <- merged_data %>%
      arrange(desc(summary.logFC))
    
    # Return a named vector with Entrez IDs as names and summary.logFC values as values
    return(setNames(merged_data$summary.logFC, merged_data$ENTREZID))
  })
```

```{r}
# Split the data by cluster and extract ranked gene names (top 100) along with summary.logFC
cluster_gene_lists_top <- markers.cell_type.up.df %>%
  split(.$cluster) %>%
  lapply(function(x) {
    # Create a data frame with both Entrez ID and summary.logFC for each gene
    mapped_genes <- bitr(x$gene, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Hs.eg.db)
    
    # Merge the mapped Entrez ID with the summary.logFC values
    merged_data <- merge(mapped_genes, x[, c("gene", "summary.logFC")], by.x = "SYMBOL", by.y = "gene")
    
    # Sort based on summary.logFC
    merged_data <- merged_data %>%
      arrange(desc(summary.logFC))
    
    # Keep only the top 100 rows
    top <- head(merged_data, 50)
    
    # Return a named vector with Entrez IDs as names and summary.logFC values as values
    # return(setNames(top$summary.logFC, top$ENTREZID))
    return(top$ENTREZID)
  })

# Inspect the top 100 genes for a specific cluster (e.g., "0")
cluster_gene_lists_top[["0"]]

reactome_results_all <- lapply(cluster_gene_lists_top, function(gene_list) {
  # Perform gsePathway on each gene list (ranked by summary.logFC)
  # enrichPathway(gene=gene_list, pvalueCutoff = 0.05, readable=TRUE)
  enrichPathway(gene=gene_list)
})
```





```{r}
## Output ranked gene lists for Shadi

# Custom sheet names mapping
custom_sheet_names <- c(
  "0" = "OC-like 1",
  "1" = "OPC-like",
  "2" = "AC-like 1",
  "3" = "1459-specific",
  "4" = "MAPKhi",
  "5" = "AC-like 2",
  "6" = "Hypoxic",
  "7" = "1171-specific",
  "8" = "OC-like 2"
)

# Rename the elements in markers.cell_type.up according to the custom sheet names
names(markers.cell_type.up) <- custom_sheet_names[as.character(seq_along(markers.cell_type.up) - 1)]

library(openxlsx)

# Create a new Excel workbook
workbook <- createWorkbook()

# Loop through all clusters (0 to 8) and add each as a sheet
lapply(names(markers.cell_type.up), function(cluster) {
  # Get the ranked gene list for the current cluster
  ranked_genes <- markers.cell_type.up[[cluster]]
  
  # Add a worksheet to the workbook
  addWorksheet(workbook, paste0(cluster))
  
  # Write the data to the worksheet
  writeData(workbook, paste0(cluster), ranked_genes)
})

# Save the workbook to a file
saveWorkbook(workbook, file = "ranked_genes_clusters.xlsx", overwrite = TRUE)

```

```{r}
# Now, you can proceed to use `cluster_gene_lists_all` for pathway analysis
library(ReactomePA)

# Reactome pathway analysis for each cluster
reactome_results_all <- lapply(cluster_gene_lists_all, function(gene_list) {
  # Perform gsePathway on each gene list (ranked by summary.logFC)
  gsePathway(geneList = gene_list, 
             pvalueCutoff = 0.2,
             pAdjustMethod = "BH", 
             verbose = FALSE)
})
```

```{r}
# Save the REACTOME results table

library(openxlsx)
library(writexl)

# Convert each result to a data frame
reactome_results_df_all <- lapply(reactome_results_all, function(result) {
  # Convert Reactome pathway results into a data frame
  as.data.frame(result)
})

# Custom sheet names mapping
custom_sheet_names <- c(
  "0" = "OC-like 1",
  "1" = "OPC-like",
  "2" = "AC-like 1",
  "3" = "1459-specific",
  "4" = "MAPKhi",
  "5" = "AC-like 2",
  "6" = "Hypoxic",
  "7" = "1171-specific",
  "8" = "OC-like 2"
)

# Rename the elements in reactome_results_df_all according to the custom sheet names
names(reactome_results_df_all) <- custom_sheet_names[as.character(seq_along(reactome_results_df_all) - 1)]

# Check the first few results
head(reactome_results_df_all[[1]])  # Check the first cluster's pathway results

# Specify the output file path
output_excel_file <- paste0(REACTOME_Analysis, "/PA_Tumor_Reactome_Pathway_Analysis_Results.xlsx")

# Write the results to an Excel file, each cluster in a different sheet
write_xlsx(reactome_results_df_all, path = output_excel_file)
```

```{r}
# Bubble Plot

library(ggplot2)
library(dplyr)

# Extract top 5 pathways for each cluster
top_pathways_all <- lapply(reactome_results_all, function(result) {
  if (!is.null(result) && nrow(result) > 0) {
    # Sort pathways by p-value (ascending order) and pick top 5
    top_pathways <- result %>%
      arrange(p.adjust) %>%   # Sort by adjusted p-value
      head(5)                  # Select top 5 pathways
    
    return(top_pathways)
  } else {
    return(NULL)  # In case there are no results for this cluster
  }
})

# Combine all top pathways into a single data frame for easier plotting
top_pathways_df <- do.call(rbind, lapply(names(top_pathways_all), function(cluster) {
  cluster_top_pathways <- top_pathways_all[[cluster]]
  
  if (!is.null(cluster_top_pathways)) {
    # Add the cluster information to the pathways data
    cluster_top_pathways$cluster <- cluster
    return(cluster_top_pathways)
  } else {
    return(NULL)
  }
}))

# Reset row names for clarity
rownames(top_pathways_df) <- NULL

# Change the new labels
# cluster 0 = OC-like 1
# cluster 1 = OPC-like
# cluster 2 = AC-like 1
# cluster 3 = 1459-specific
# cluster 4 = MAPKhi
# cluster 5 = AC-like 2
# cluster 6 = Hypoxic
# cluster 7 = 1171-specific
# cluster 8 = OC-like 2

library(dplyr)

# Create a mapping of cluster numbers to cell types
cluster_to_cell_type <- c(
  "0" = "OC-like 1",
  "1" = "OPC-like",
  "2" = "AC-like 1",
  "3" = "1459-specific",
  "4" = "MAPKhi",
  "5" = "AC-like 2",
  "6" = "Hypoxic",
  "7" = "1171-specific",
  "8" = "OC-like 2"
)

# Add a 'cell_type' column to the top_pathways_df based on the cluster number
top_pathways_df <- top_pathways_df %>%
  mutate(cell_type = cluster_to_cell_type[as.character(cluster)])

# Ensure cell_type is ordered according to the desired mapping
top_pathways_df$cell_type <- factor(
  top_pathways_df$cell_type,
  levels = c(
    "OC-like 1",
    "OPC-like",
    "AC-like 1",
    "1459-specific",
    "MAPKhi",
    "AC-like 2",
    "Hypoxic",
    "1171-specific",
    "OC-like 2"
  )
)

# Save the updated plot as a PDF
pdf(paste0(REACTOME_Analysis, "/PA_Tumor_REACTOME_Pathway_Analysis_Bubble_Plot.pdf"), height = 6, width = 10)

# Bubble plot with cell_type on x-axis, ordered explicitly
# ggplot(top_pathways_df, aes(x = cell_type, y = reorder(Description, p.adjust), size = -log10(p.adjust), color = NES)) +
ggplot(top_pathways_df, aes(x = cell_type, y = reorder(Description, p.adjust), size = -log10(p.adjust), color = zScore)) +
  geom_point(alpha = 0.7) +
  theme_minimal() +
  scale_color_gradient(low = "blue", high = "red", name = "zScore") +  # NES values as color gradient
  labs(title = "PA Tumor Top Reactome Pathways",
       x = "Cell Type",
       y = "Pathway") +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 8),  # Rotate x-axis labels
    axis.text.y = element_text(size = 8),
    legend.position = "right"
  )

dev.off()
```

```{r}
# # Test: REACTOME pathway Analysis
# # enrichPathway() - top 200 markers
# 
# # Split top markers by cluster
# pa_top200_markers <- markers.cell_type.up %>%
#   group_by(cluster) %>%
#   top_n(n = 200, wt = avg_log2FC)
# 
# cluster_gene_lists <- pa_top200_markers %>%
#   split(.$cluster) %>%
#   lapply(function(x) x$gene) # Extract only gene names
# 
# library(org.Hs.eg.db)
# library(clusterProfiler)
# 
# # Map gene symbols to Entrez IDs
# entrez_lists <- lapply(cluster_gene_lists, function(genes) {
#   bitr(genes, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Hs.eg.db) %>%
#     pull(ENTREZID) %>% 
#     unique()  # Get unique Entrez IDs
# })
# 
# library(ReactomePA)
# # Reactome pathway analysis for each cluster
# reactome_results <- lapply(entrez_lists, function(entrez_ids) {
#   enrichPathway(gene = entrez_ids, 
#                 organism = "human", 
#                 pvalueCutoff = 0.05, 
#                 qvalueCutoff = 0.05,
#                 readable=TRUE)
# })
# 
# reactome_results_ENTREZID <- lapply(entrez_lists, function(entrez_ids) {
#   enrichPathway(gene = entrez_ids, 
#                 organism = "human", 
#                 pvalueCutoff = 0.05, 
#                 qvalueCutoff = 0.05)
# })
# 
# # # Inspect results for a specific cluster (e.g., cluster 0)
# # head(reactome_results[[1]]@result)
# 
# # Extract top 5 pathways per cluster
# top_pathways <- lapply(reactome_results, function(result) {
#   result@result %>%
#     filter(p.adjust < 0.05) %>%
#     arrange(p.adjust) %>%
#     head(5)  # Top 5 pathways
# })
# 
# # Not the same number of top pathways
# # Convert to a data frame for easy inspection
# top_pathways_df <- do.call(rbind, lapply(names(top_pathways), function(cluster) {
#   pathways <- top_pathways[[cluster]]
#   pathways$cluster <- cluster
#   pathways
# }))
# 
# # Save the top pathways as a CSV
# csv_path <- file.path(REACTOME_Analysis, "pa_tumor_top_5_pathways_each_cluster_df.csv")
# write.csv(top_pathways_df, csv_path, row.names = FALSE)
```

### ssGSEA

```{r}
ssGSEA_Analysis = paste0(Kent_res, "/ssGSEA_Analysis")

if(!exists(ssGSEA_Analysis)){
  dir.create(ssGSEA_Analysis, recursive = TRUE)
}
```

```{r}
suppressPackageStartupMessages(library(escape))
suppressPackageStartupMessages(library(SingleCellExperiment))
suppressPackageStartupMessages(library(scran))
suppressPackageStartupMessages(library(Seurat))
suppressPackageStartupMessages(library(SeuratObject))
suppressPackageStartupMessages(library(RColorBrewer))
suppressPackageStartupMessages(library(ggplot2))

# ssGSEA - This method calculates the enrichment score using a rank-normalized approach and generating an empirical cumulative distribution function for each individual cell. The enrichment score is defined for a gene set (G) using the number of genes in the gene set (NG) and total number of genes (N).
```

```{r}
GS.hallmark <- getGeneSets(library = "H")

# escape has 2 major functions - the first being escape.matrix(), which serves as the backbone of enrichment calculations. Using count-level data supplied from a single-cell object or matrix, escape.matrix() will produce an enrichment score for the individual cells with the gene sets selected and output the values as a matrix.
# groups: The number of random permutations used for calculating enrichment.
# min.size: The minimum size of gene sets to consider.
enrichment.scores <- escape.matrix(sce, 
                                   gene.sets = GS.hallmark, 
                                   groups = 1000, 
                                   min.size = 5)
```

```{r}
so_pa@meta.data
```

```{r}
plot_harmony(so_pa, "cell_type", legend_title = "Cell Type") 
```

```{r}
# Check if rownames of enrichment.scores match rownames of so_pa@meta.data
if (!all(rownames(enrichment.scores) %in% rownames(so_pa@meta.data))) {
  stop("Some cell barcodes in enrichment.scores do not match those in so_pa@meta.data")
}

# Add enrichment.scores to so_pa@meta.data
so_pa@meta.data <- cbind(
  so_pa@meta.data,
  enrichment.scores[rownames(so_pa@meta.data), ]  # Align enrichment scores by rownames
)

so_pa@meta.data
```

```{r}
FeaturePlot(so_pa, features = "HALLMARK-ADIPOGENESIS") +
  scale_color_gradient(low = "blue", high = "red", name = "Adipogenesis") +
  labs(title = "UMAP colored by HALLMARK-ADIPOGENESIS") +
  theme_minimal()
```

```{r}
library(ggplot2)

# Extract UMAP coordinates
umap_data <- as.data.frame(Embeddings(so_pa, reduction = "harmony_umap"))
umap_data$cell_type <- so_pa@meta.data$cell_type
umap_data$adipogenesis <- so_pa@meta.data$`HALLMARK-ADIPOGENESIS`

ggplot(umap_data, aes(x = UMAP_1, y = UMAP_2)) +
  geom_point(aes(color = adipogenesis), alpha = 0.4, size = 1) +  # Transparent points
  scale_color_gradient(low = "blue", high = "red", name = "Pathway Values") +
  geom_text(data = umap_data %>% group_by(cell_type) %>% summarize(
    UMAP_1 = mean(UMAP_1),
    UMAP_2 = mean(UMAP_2)
  ), aes(label = cell_type), size = 2, fontface = "bold") +  # Add cell type labels
  theme_minimal() +
  labs(title = "UMAP with HALLMARK-ADIPOGENESIS and Cell Type",
       x = "UMAP 1", y = "UMAP 2") +
  theme(
    legend.position = "right",
    axis.text = element_blank(),
    axis.ticks = element_blank()
  )
```

```{r}
library(ggplot2)

# Extract UMAP coordinates
umap_data <- as.data.frame(Embeddings(so_pa, reduction = "harmony_umap"))
umap_data$cell_type <- so_pa@meta.data$cell_type
umap_data$adipogenesis <- so_pa@meta.data$`HALLMARK-ALLOGRAFT-REJECTION`

ggplot(umap_data, aes(x = UMAP_1, y = UMAP_2)) +
  geom_point(aes(color = adipogenesis), alpha = 0.4, size = 1) +  # Transparent points
  scale_color_gradient(low = "blue", high = "red", name = "Pathway Values") +
  geom_text(data = umap_data %>% group_by(cell_type) %>% summarize(
    UMAP_1 = mean(UMAP_1),
    UMAP_2 = mean(UMAP_2)
  ), aes(label = cell_type), size = 2, fontface = "bold") +  # Add cell type labels
  theme_minimal() +
  labs(title = "UMAP with HALLMARK-ALLOGRAFT-REJECTION and Cell Type",
       x = "UMAP 1", y = "UMAP 2") +
  theme(
    legend.position = "right",
    axis.text = element_blank(),
    axis.ticks = element_blank()
  )
```

### GO Analysis

```{r}
GO_Analysis = paste0(Kent_res, "/GO_Analysis")

if(!exists(GO_Analysis)){
  dir.create(GO_Analysis, recursive = TRUE)
}
```

```{r}
############# GO pathway #############
#####gseGO()
# Shadi interested GO pathways:
# GO:0031175
# GO:0042552
# GO:0042063
# GO:0007156
# GO:0061564
# GO:0010001
# GO:0051960
# GO:0021762
# GO:0031102

# GO pathway analysis for each cluster
go_results_all <- lapply(cluster_gene_lists_all, function(gene_list) {
  # Perform gseGO on each gene list (ranked by summary.logFC)
  gseGO(geneList = gene_list, # A ranked list of genes 
        OrgDb = org.Hs.eg.db,
        ont = "BP",
        minGSSize    = 10,
        maxGSSize    = 1000,
        pvalueCutoff = 1,
        verbose      = FALSE)
})

```

```{r}
library(clusterProfiler)
library(org.Hs.eg.db)

go_results_all <- lapply(cluster_gene_lists_all, function(gene_list) {
  # Perform gseGO on each gene list (ranked by summary.logFC)
  ego <- enrichGO(gene = gene_list,
                universe = names(gene_list),
                OrgDb = org.Hs.eg.db,
                ont = "CC",
                pAdjustMethod = "BH",
                pvalueCutoff  = 1,
                qvalueCutoff  = 1,
        readable      = TRUE)
})
```

```{r}
# Save the GO results table

library(openxlsx)
library(writexl)

# Convert each result to a data frame
go_results_df_all <- lapply(go_results_all, function(result) {
  # Convert Reactome pathway results into a data frame
  as.data.frame(result)
})

# Custom sheet names mapping
custom_sheet_names <- c(
  "0" = "OC-like 1",
  "1" = "OPC-like",
  "2" = "AC-like 1",
  "3" = "1459-specific",
  "4" = "MAPKhi",
  "5" = "AC-like 2",
  "6" = "Hypoxic",
  "7" = "1171-specific",
  "8" = "OC-like 2"
)

# Rename the elements in go_results_df_all according to the custom sheet names
names(go_results_df_all) <- custom_sheet_names[as.character(seq_along(go_results_df_all) - 1)]

# Check the first few results
head(go_results_df_all[[1]])  # Check the first cluster's pathway results

# Specify the output file path
output_excel_file <- paste0(GO_Analysis, "/PA_Tumor_GO_Pathway_Analysis_Results.xlsx")

# Write the results to an Excel file, each cluster in a different sheet
write_xlsx(go_results_df_all, path = output_excel_file)
```

```{r}
# Define the GO terms of interest
shadi_go_terms <- c(
  "GO:0031175", "GO:0042552", "GO:0042063", "GO:0007156",
  "GO:0061564", "GO:0010001", "GO:0051960", "GO:0021762", "GO:0031102"
)

# Filter the GO results for each cluster
go_results_subset <- lapply(go_results_df_all, function(df) {
  if (!is.null(df)) {
    subset(df, ID %in% shadi_go_terms)  # Assuming the GO term is in the 'ID' column
  } else {
    NULL
  }
})

# Remove empty clusters (if no terms matched)
go_results_subset <- go_results_subset[sapply(go_results_subset, nrow) > 0]

# Specify the output file path for the subset
output_subset_excel_file <- paste0(GO_Analysis, "/PA_Tumor_GO_Pathway_Analysis_Results_Subset.xlsx")

# Write the subset results to an Excel file, each cluster in a different sheet
write_xlsx(go_results_subset, path = output_subset_excel_file)

go_results_subset
```





### WP Analysis

```{r}
WP_Analysis = paste0(Kent_res, "/WP_Analysis")

if(!exists(WP_Analysis)){
  dir.create(WP_Analysis, recursive = TRUE)
}
```

```{r}
############# WP pathway #############
#####gseWP()
# Shadi interested WP pathways:
# WP4304
# WP111
# WP2276


# WP pathway analysis for each cluster
wp_results_all <- lapply(cluster_gene_lists_all, function(gene_list) {
  enrichWP(gene_list, organism = "Homo sapiens") 
})

```

```{r}
wp_results_all <- lapply(cluster_gene_lists_all, function(gene_list) {
  # Perform gseWP on each gene list (ranked by summary.logFC)
  gseWP(geneList = gene_list, 
        organism = "Homo sapiens",
        minGSSize    = 6,
        maxGSSize    = 1000,
        pvalueCutoff = 1)
})
```

```{r}
# Save the WP results table

library(openxlsx)
library(writexl)

# Convert each result to a data frame
wp_results_df_all <- lapply(wp_results_all, function(result) {
  # Convert Reactome pathway results into a data frame
  as.data.frame(result)
})

# Custom sheet names mapping
custom_sheet_names <- c(
  "0" = "OC-like 1",
  "1" = "OPC-like",
  "2" = "AC-like 1",
  "3" = "1459-specific",
  "4" = "MAPKhi",
  "5" = "AC-like 2",
  "6" = "Hypoxic",
  "7" = "1171-specific",
  "8" = "OC-like 2"
)

# Rename the elements in wp_results_df_all according to the custom sheet names
names(wp_results_df_all) <- custom_sheet_names[as.character(seq_along(wp_results_df_all) - 1)]

# Check the first few results
head(wp_results_df_all[[1]])  # Check the first cluster's pathway results

# Specify the output file path
output_excel_file <- paste0(WP_Analysis, "/PA_Tumor_WP_Pathway_Analysis_Results.xlsx")

# Write the results to an Excel file, each cluster in a different sheet
write_xlsx(wp_results_df_all, path = output_excel_file)
```

```{r}
# Define the WP terms of interest
shadi_wp_terms <- c(
  "WP4304", "WP111", "WP2276"
)

# Filter the GO results for each cluster
wp_results_subset <- lapply(wp_results_df_all, function(df) {
  if (!is.null(df)) {
    subset(df, ID %in% shadi_wp_terms)  # Assuming the GO term is in the 'ID' column
  } else {
    NULL
  }
})

# Remove empty clusters (if no terms matched)
wp_results_subset <- wp_results_subset[sapply(wp_results_subset, nrow) > 0]

# Specify the output file path for the subset
output_subset_excel_file <- paste0(WP_Analysis, "/PA_Tumor_WP_Pathway_Analysis_Results_Subset.xlsx")

# Write the subset results to an Excel file, each cluster in a different sheet
write_xlsx(wp_results_subset, path = output_subset_excel_file)

```

```{r}
# Shadi interested WP pathways:
# WP4304
# WP111
# WP2276

library(org.Hs.eg.db)

# Your list of Entrez Gene IDs
WP4304_gene_ids <- c(5354, 116448, 1267, 10215, 30812, 55553, 4974, 4340, 6663, 4821, 429, 4099, 4661, 6660)
WP111_gene_ids <- c(4697, 4708, 1345, 514, 51079, 1337, 1350, 1347, 517, 1329, 4718, 1351, 
              4725, 1327, 4714, 10632, 10975, 7381, 27089, 513, 518, 4713, 522, 1340, 
              9551, 4694, 292, 521, 126328, 93974, 1349, 29796, 7388, 516, 4710, 4706, 
              539, 4715, 4726, 509, 506, 9377, 4716, 4729, 498, 4696, 4728, 10476, 291, 
              515, 4707, 4709, 293, 4698, 374291, 4702, 4717, 4711, 7386, 4695, 4712, 
              55967, 10063, 4701, 4700, 4724, 4722, 7384, 4723, 4719)

# Map Entrez Gene IDs to Gene Symbols for WP4304 and WP111
WP4304_gene_symbols <- mapIds(org.Hs.eg.db, 
                              keys = as.character(WP4304_gene_ids), 
                              column = "SYMBOL", 
                              keytype = "ENTREZID", 
                              multiVals = "first")

WP111_gene_symbols <- mapIds(org.Hs.eg.db, 
                             keys = as.character(WP111_gene_ids), 
                             column = "SYMBOL", 
                             keytype = "ENTREZID", 
                             multiVals = "first")

WP4304_gene_symbols <- as.character(WP4304_gene_symbols) 
WP111_gene_symbols <- as.character(WP111_gene_symbols) 

# Initialize gene.sets as an empty list
gene.sets <- list()

# Add the WP4304 and WP111 gene sets to gene.sets
gene.sets$WP4304 <- WP4304_gene_symbols
gene.sets$WP111 <- WP111_gene_symbols

gene.sets
```

```{r}
enrichment.scores <- escape.matrix(sce, 
                                   gene.sets = gene.sets, 
                                   groups = 1000, 
                                   min.size = 5)
```

```{r}
# Check if rownames of enrichment.scores match rownames of so_pa@meta.data
if (!all(rownames(enrichment.scores) %in% rownames(so_pa@meta.data))) {
  stop("Some cell barcodes in enrichment.scores do not match those in so_pa@meta.data")
}

# Add enrichment.scores to so_pa@meta.data
so_pa@meta.data <- cbind(
  so_pa@meta.data,
  enrichment.scores[rownames(so_pa@meta.data), ]  # Align enrichment scores by rownames
)

so_pa@meta.data
```

```{r}
library(ggplot2)

# Extract UMAP coordinates
umap_data <- as.data.frame(Embeddings(so_pa, reduction = "harmony_umap"))
umap_data$cell_type <- so_pa@meta.data$cell_type
umap_data$adipogenesis <- so_pa@meta.data$`WP4304`
library(viridis)
ggplot(umap_data, aes(x = UMAP_1, y = UMAP_2)) +
  geom_point(aes(color = adipogenesis), alpha = 0.4, size = 1) +  # Transparent points
  # scale_color_gradient(low = "blue", high = "red", name = "Pathway Values") +
  scale_color_viridis(option = "viridis", name = "Adipogenesis", direction = 1) +
  geom_text(data = umap_data %>% group_by(cell_type) %>% summarize(
    UMAP_1 = mean(UMAP_1),
    UMAP_2 = mean(UMAP_2)
  ), aes(label = cell_type), size = 2, fontface = "bold") +  # Add cell type labels
  theme_minimal() +
  labs(title = "UMAP with WP4304 and Cell Type",
       x = "UMAP 1", y = "UMAP 2") +
  theme(
    legend.position = "right",
    axis.text = element_blank(),
    axis.ticks = element_blank()
  )
```

```{r}
library(ggplot2)

# Extract UMAP coordinates
umap_data <- as.data.frame(Embeddings(so_pa, reduction = "harmony_umap"))
umap_data$cell_type <- so_pa@meta.data$cell_type
umap_data$adipogenesis <- so_pa@meta.data$`WP111`

ggplot(umap_data, aes(x = UMAP_1, y = UMAP_2)) +
  geom_point(aes(color = adipogenesis), alpha = 0.4, size = 1) +  # Transparent points
  scale_color_gradient(low = "blue", high = "red", name = "Pathway Values") +
  geom_text(data = umap_data %>% group_by(cell_type) %>% summarize(
    UMAP_1 = mean(UMAP_1),
    UMAP_2 = mean(UMAP_2)
  ), aes(label = cell_type), size = 2, fontface = "bold") +  # Add cell type labels
  theme_minimal() +
  labs(title = "UMAP with WP111 and Cell Type",
       x = "UMAP 1", y = "UMAP 2") +
  theme(
    legend.position = "right",
    axis.text = element_blank(),
    axis.ticks = element_blank()
  )
```

## Dot plot for GO and WP

```{r}
go_results_subset
```

```{r}
wp_results_subset
```

```{r}
library(dplyr)
library(writexl)

# Combine all clusters' results into one data frame
go_results_combined <- do.call(rbind, lapply(names(go_results_subset), function(cluster_name) {
  # Get the data frame for the current cluster
  cluster_df <- go_results_subset[[cluster_name]]
  
  if (!is.null(cluster_df)) {
    # Add the cluster name as a new column
    cluster_df$Cluster <- cluster_name
  }
  
  return(cluster_df)
}))

wp_results_combined <- do.call(rbind, lapply(names(wp_results_subset), function(cluster_name) {
  # Get the data frame for the current cluster
  cluster_df <- wp_results_subset[[cluster_name]]
  
  if (!is.null(cluster_df)) {
    # Add the cluster name as a new column
    cluster_df$Cluster <- cluster_name
  }
  
  return(cluster_df)
}))

all_results_combined <- rbind(
  mutate(go_results_combined, Source = "GO"),
  mutate(wp_results_combined, Source = "WP")
)
```

```{r}
library(ggplot2)
library(dplyr)

# Prepare the combined data for visualization
all_results_combined <- all_results_combined %>%
  mutate(
    Cluster = factor(Cluster)    # Ensure Cluster is treated as a factor
  )

# Create the dot plot with NES and p-value
dot_plot <- ggplot(all_results_combined, aes(x = Cluster, y = ID, size = pvalue, color = NES)) +
  geom_point() +
  scale_size_continuous(name = "p-value", range = c(1, 6), trans = "reverse") +  # Smaller p-value = larger dot
  scale_color_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0, name = "NES") +
  labs(
    title = "PA Tumor GO and WP Pathway Analysis",
    x = "Cluster",
    y = "Pathway"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.title = element_text(hjust = 0.5, face = "bold")
  )

# Print the plot
print(dot_plot)

output_excel_file <- paste0(WP_Analysis, "/PA_Tumor_GO_WP_table.xlsx")
write_xlsx(all_results_combined, path = output_excel_file)

```



## GG-Tumor

### Top 10 Markers Dot Plot

```{r}
so_gg <- qread(file.path("..", "tumor", "objects", "so_tumor_gg2.qs"))

library(scran)
so_gg$Dx_simple <- ifelse(str_detect(so_gg$Dx, "low grade glioma"),
                       "low grade glioma",
                       so_gg$Dx)
# temporary fix for issue #4639
so_diet <- DietSeurat(so_gg, graphs = "pca")
sce <- as.SingleCellExperiment(so_diet)
rm(so_diet)

sce$gg_tumor_harmony_res.0.7 <- droplevels(sce$gg_tumor_harmony_res.0.7)
markers.cell_type.up <- findMarkers(sce,
                                groups = sce$gg_tumor_harmony_res.0.7,
                                block = sce$orig.ident,
                                lfc = 0.5,
                                direction="up") %>%
  lapply(., as.data.frame) %>%
  map(~rownames_to_column(.x, "gene") %>%
        filter(FDR < 0.05))

# markers.cell_type.up %>% 
#   bind_rows(.id = "cluster") %>% 
#   write_tsv(file.path(mkrs_dir, "scran_gg_tumor_consensus_cluster_markers.tsv"))
# 
# map(markers.cell_type.up, 
#     ~set_xlsx_class(.x, "gene", "Text")) %>% 
# openxlsx::write.xlsx(., file.path(mkrs_dir, "scran_gg_tumor_consensus_cluster_markers.xlsx"),
#                      overwrite = TRUE)
```

```{r}
plot_harmony(so_gg, "gg_tumor_harmony_res.0.7", legend_title = "harmony-clusters") 
```

```{r}
so_gg@meta.data
```

```{r}
# Change the new labels
# cluster 0 = OPC-like
# cluster 6 = OPC-like
# cluster 2 = Glycolysis_hi
# cluster 4 = Glycolysis_hi
# cluster 10 = Glycolysis_hi
# cluster 5 = AC-like 1
# cluster 8 = AC-like 1
# cluster 1 = Ribosome_hi
# cluster 9 = Neuron-like
# cluster 7 = AC-like 2
# cluster 12 = OC-like

# Add the 'cell_type' column to the metadata using case_when
so_gg@meta.data <- so_gg@meta.data %>%
  mutate(cell_type = case_when(
    gg_tumor_harmony_res.0.7 %in% c(0, 6) ~ "OPC-like",
    gg_tumor_harmony_res.0.7 %in% c(2, 4, 10) ~ "Glycolysis_hi",
    gg_tumor_harmony_res.0.7 %in% c(5, 8) ~ "AC-like 1",
    gg_tumor_harmony_res.0.7 == 1 ~ "Ribosome_hi",
    gg_tumor_harmony_res.0.7 == 9 ~ "Neuron-like",
    gg_tumor_harmony_res.0.7 == 7 ~ "AC-like 2",
    gg_tumor_harmony_res.0.7 == 12 ~ "OC-like",
    TRUE ~ NA_character_  # Default case if no match is found
  ))

so_gg@meta.data
```

```{r}
plot_harmony(so_gg, "cell_type", legend_title = "harmony-clusters") 
```

```{r}
# Select the top 10 genes from each group and combine them into a single data frame
top_genes_df <- lapply(names(markers.cell_type.up), function(group) {
  markers.cell_type.up[[group]] %>%
    arrange(desc(summary.logFC)) %>%  # Sort by logFC in descending order
    head(10) %>%        
    mutate(group = group)    # Add a column to identify the group
}) %>%
  bind_rows() # Combine all groups into a single data frame

top_genes_df
```

```{r}
# Change the new labels
# cluster 0 = OPC-like
# cluster 6 = OPC-like
# cluster 2 = Glycolysis_hi
# cluster 4 = Glycolysis_hi
# cluster 10 = Glycolysis_hi
# cluster 5 = AC-like 1
# cluster 8 = AC-like 1
# cluster 1 = Ribosome_hi
# cluster 9 = Neuron-like
# cluster 7 = AC-like 2
# cluster 12 = OC-like


top_genes_df <- top_genes_df %>%
  mutate(cell_type = recode(group,
                            `0` = "OPC-like",
                            `6` = "OPC-like",
                            `2` = "Glycolysis_hi",
                            `4` = "Glycolysis_hi",
                            `10` = "Glycolysis_hi",
                            `5` = "AC-like 1",
                            `8` = "AC-like 1",
                            `1` = "Ribosome_hi",
                            `9` = "Neuron-like",
                            `7` = "AC-like 2",
                            `12` = "OC-like"),
         cell_type = factor(cell_type, levels = c("OPC-like", "Glycolysis_hi", "AC-like 1", 
                                                  "Ribosome_hi", "Neuron-like", "AC-like 2", 
                                                  "OC-like")))

top_genes_df
```

```{r}
# Ensure the gene order matches the original order in top_genes_df
top_genes_df <- top_genes_df %>%
  mutate(gene = factor(gene, levels = unique(gene)))

logFC_midpoint <- mean(top_genes_df$summary.logFC)  # Use the mean of logFC as midpoint

# Create the dot plot
dot_plot <- ggplot(top_genes_df, aes(x = cell_type, y = gene)) +
  geom_point(aes(size = -log10(FDR), color = summary.logFC)) +
  scale_color_gradient2(low = "blue", mid = "grey", high = "red", midpoint = logFC_midpoint) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
  ) +
  labs(color = "logFC", size = "-log10(FDR)")

dot_plot

# Specify the file path
output_file <- file.path(Dot_plot, "DotPlot_TopGenes_GG_Tumor_org.pdf")

ggsave(output_file, plot = dot_plot, width = 8, height = 10)
```

```{r}
# Remove Duplicates genes
# Because some clusters combined together, so only plot the biggest value to avoid duplicates.

# Ensure the gene order matches the original order in top_genes_df
top_genes_df <- top_genes_df %>%
  mutate(gene = factor(gene, levels = unique(gene)))

# Remove duplicate genes within each cell_type, keeping the row with the highest absolute logFC
top_genes_df_unique <- top_genes_df %>%
  group_by(cell_type, gene) %>%
  filter(abs(summary.logFC) == max(abs(summary.logFC))) %>%
  ungroup()

# Calculate the midpoint for logFC (based on unique genes)
logFC_midpoint <- mean(top_genes_df_unique$summary.logFC)

# Create the dot plot with unique genes
dot_plot <- ggplot(top_genes_df_unique, aes(x = cell_type, y = gene)) +
  geom_point(aes(size = -log10(FDR), color = summary.logFC)) +
  scale_color_gradient2(low = "blue", mid = "grey", high = "red", midpoint = logFC_midpoint) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
  ) +
  labs(color = "logFC", size = "-log10(FDR)")

# Display the plot
dot_plot

# Specify the output file path
output_file <- file.path(Dot_plot, "DotPlot_TopGenes_GG_Tumor.pdf")

# Save the plot to a file
ggsave(output_file, plot = dot_plot, width = 8, height = 10)
```

### REACTOME Analysis

```{r}
############# REACTOME pathway #############
#####gsePathway()

library(org.Hs.eg.db)
library(clusterProfiler)

sce$gg_tumor_harmony_res.0.7 <- droplevels(sce$gg_tumor_harmony_res.0.7)
# Without filter, use all markers.
markers.cell_type.up <- findMarkers(sce, 
                                groups = sce$gg_tumor_harmony_res.0.7, 
                                block = sce$orig.ident,
                                lfc = 0.5,
                                direction="up") %>% 
  lapply(., as.data.frame) %>%
  map(~rownames_to_column(.x, "gene"))

# Keep only the first five columns for each cluster
markers.cell_type.up <- lapply(markers.cell_type.up, function(df) {
  df[, c("gene", "Top", "p.value", "FDR", "summary.logFC")]
})

# Combine all clusters into a single data frame with the cluster information
markers.cell_type.up.df <- do.call(rbind, lapply(names(markers.cell_type.up), function(cluster) {
  cluster_markers <- markers.cell_type.up[[cluster]]
  cluster_markers$cluster <- cluster  # Add cluster information
  return(cluster_markers)
}))

# Reset row names for clarity
rownames(markers.cell_type.up.df) <- NULL

# Rank genes within each cluster based on summary.logFC (you can adjust the order if needed)
markers.cell_type.up.df <- markers.cell_type.up.df %>%
  group_by(cluster) %>%
  arrange(cluster, desc(summary.logFC)) %>%
  ungroup()

# Split the data by cluster and extract ranked gene names along with summary.logFC
cluster_gene_lists_all <- markers.cell_type.up.df %>%
  split(.$cluster) %>%
  lapply(function(x) {
    # Create a data frame with both Entrez ID and summary.logFC for each gene
    mapped_genes <- bitr(x$gene, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Hs.eg.db)
    
    # Merge the mapped Entrez ID with the summary.logFC values
    merged_data <- merge(mapped_genes, x[, c("gene", "summary.logFC")], by.x = "SYMBOL", by.y = "gene")
    
    # Sort based on summary.logFC
    merged_data <- merged_data %>%
      arrange(desc(summary.logFC))
    
    # Return a named vector with Entrez IDs as names and summary.logFC values as values
    return(setNames(merged_data$summary.logFC, merged_data$ENTREZID))
  })

# Now, you can proceed to use `cluster_gene_lists_all` for pathway analysis
library(ReactomePA)

# Reactome pathway analysis for each cluster
reactome_results_all <- lapply(cluster_gene_lists_all, function(gene_list) {
  # Perform gsePathway on each gene list (ranked by summary.logFC)
  gsePathway(geneList = gene_list, 
             pvalueCutoff = 0.2,
             pAdjustMethod = "BH", 
             verbose = FALSE)
})
```

```{r}
# Save the REACTOME results table

library(openxlsx)
library(writexl)

# Convert each result to a data frame
reactome_results_df_all <- lapply(reactome_results_all, function(result) {
  # Convert Reactome pathway results into a data frame
  as.data.frame(result)
})

# Custom sheet names mapping using the according order from reactome_results_all (number, like 0, 1, 10, 12, 2...)
custom_sheet_names <- c(
  "0" = "OPC-like",
  "1" = "Ribosome_hi",
  "10" = "Glycolysis_hi",
  "12" = "OC-like",
  "2" = "Glycolysis_hi",
  "4" = "Glycolysis_hi",
  "5" = "AC-like 1",
  "6" = "OPC-like",
  "7" = "AC-like 2",
  "8" = "AC-like 1", 
  "9"= "Neuron-like"
)

list_lack_3 <- c(0, 1, 10, 12, 2, 4, 5, 6, 7, 8, 9)
  
# Rename the elements in reactome_results_df_all according to the custom sheet names
names(reactome_results_df_all) <- custom_sheet_names[as.character(list_lack_3)]

# For Combine
reactome_results_df_all_cb <- lapply(reactome_results_all, function(result) {
  # Convert Reactome pathway results into a data frame
  as.data.frame(result)
})

# Combine results for clusters with the same sheet name into one
combined_results <- list()

for (sheet_name in unique(custom_sheet_names[as.character(list_lack_3)])) {
  # Find the clusters with the same sheet name
  matching_clusters <- names(reactome_results_df_all_cb)[custom_sheet_names[names(reactome_results_df_all_cb)] == sheet_name]
  
  # Combine results for these clusters (using bind_rows to combine data frames)
  combined_results[[sheet_name]] <- do.call(rbind, reactome_results_df_all_cb[matching_clusters])
}

# Check the combined results for one of the sheet names
head(combined_results[["Glycolysis_hi"]])  # For example, check the combined 'Glycolysis_hi' sheet

# Specify the output file path
output_excel_file <- paste0(REACTOME_Analysis, "/GG_Tumor_Reactome_Pathway_Analysis_Results.xlsx")

# Write the combined results to an Excel file, with one sheet for each unique name
write_xlsx(combined_results, path = output_excel_file)
```

```{r}
# Bubble Plot

library(ggplot2)
library(dplyr)

# Extract top 5 pathways for each cluster
top_pathways_all <- lapply(reactome_results_all, function(result) {
  if (!is.null(result) && nrow(result) > 0) {
    # Sort pathways by p-value (ascending order) and pick top 5
    top_pathways <- result %>%
      arrange(p.adjust) %>%   # Sort by adjusted p-value
      head(5)                  # Select top 5 pathways
    
    return(top_pathways)
  } else {
    return(NULL)  # In case there are no results for this cluster
  }
})

# Combine all top pathways into a single data frame for easier plotting
top_pathways_df <- do.call(rbind, lapply(names(top_pathways_all), function(cluster) {
  cluster_top_pathways <- top_pathways_all[[cluster]]
  
  if (!is.null(cluster_top_pathways)) {
    # Add the cluster information to the pathways data
    cluster_top_pathways$cluster <- cluster
    return(cluster_top_pathways)
  } else {
    return(NULL)
  }
}))

# Reset row names for clarity
rownames(top_pathways_df) <- NULL

# Change the new labels
# cluster 0 = OPC-like
# cluster 6 = OPC-like
# cluster 2 = Glycolysis_hi
# cluster 4 = Glycolysis_hi
# cluster 10 = Glycolysis_hi
# cluster 5 = AC-like 1
# cluster 8 = AC-like 1
# cluster 1 = Ribosome_hi
# cluster 9 = Neuron-like
# cluster 7 = AC-like 2
# cluster 12 = OC-likes

# Create a mapping of cluster numbers to cell types
cluster_to_cell_type <- c(
  "0" = "OPC-like",
  "6" = "OPC-like",
  "2" = "Glycolysis_hi",
  "4" = "Glycolysis_hi",
  "10" = "Glycolysis_hi",
  "5" = "AC-like 1",
  "8" = "AC-like 1",
  "1" = "Ribosome_hi",
  "9" = "Neuron-like",
  "7" = "AC-like 2",
  "12" = "OC-like"
)

# Add a 'cell_type' column to the top_pathways_df based on the cluster number
top_pathways_df <- top_pathways_df %>%
  mutate(cell_type = cluster_to_cell_type[as.character(cluster)])

# Ensure cell_type is ordered according to the desired mapping
top_pathways_df$cell_type <- factor(
  top_pathways_df$cell_type,
  levels = c(
    "OPC-like",
    "Glycolysis_hi",
    "AC-like 1",
    "Ribosome_hi",
    "Neuron-like",
    "AC-like 2",
    "OC-like"
  )
)

# Save the updated plot as a PDF
pdf(paste0(REACTOME_Analysis, "/GG_Tumor_REACTOME_Analysis_Bubble_Plot_org.pdf"), height = 6, width = 10)

# Bubble plot with cell_type on x-axis, ordered explicitly
ggplot(top_pathways_df, aes(x = cell_type, y = reorder(Description, p.adjust), size = -log10(p.adjust), color = NES)) +
  geom_point(alpha = 0.7) +
  theme_minimal() +
  scale_color_gradient(low = "blue", high = "red", name = "NES") +  # NES values as color gradient
  labs(title = "GG Tumor Top Reactome Pathways",
       x = "Cell Type",
       y = "Pathway") +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 8),  # Rotate x-axis labels
    axis.text.y = element_text(size = 8),
    legend.position = "right"
  )

dev.off()

# Only keep top 5 each cluster, removing duplicates
# Combine rows with the same cell_type
combined_pathways_df <- top_pathways_df %>%
  group_by(cell_type) %>%
  arrange(cell_type, p.adjust) %>%
  slice_head(n = 5) %>%
  ungroup()

# Ensure cell_type is ordered according to the desired mapping
combined_pathways_df$cell_type <- factor(
  combined_pathways_df$cell_type,
  levels = c(
    "OPC-like",
    "Glycolysis_hi",
    "AC-like 1",
    "Ribosome_hi",
    "Neuron-like",
    "AC-like 2",
    "OC-like"
  )
)

# Save the updated plot as a PDF
pdf(paste0(REACTOME_Analysis, "/GG_Tumor_REACTOME_Analysis_Bubble_Plot.pdf"), height = 6, width = 10)

# Bubble plot with cell_type on x-axis, ordered explicitly
ggplot(combined_pathways_df, aes(x = cell_type, y = reorder(Description, p.adjust), size = -log10(p.adjust), color = NES)) +
  geom_point(alpha = 0.7) +
  theme_minimal() +
  scale_color_gradient(low = "blue", high = "red", name = "NES") +  # NES values as color gradient
  labs(title = "GG Tumor Top Reactome Pathways",
       x = "Cell Type",
       y = "Pathway") +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 8),  # Rotate x-axis labels
    axis.text.y = element_text(size = 8),
    legend.position = "right"
  )

dev.off()
```

## PA-Immune

### Top 10 Markers Dot Plot

```{r}
set.seed(99)

so <- qread(file.path("..", "immune", "objects", "so_myeloid.qs"), nthreads = 4)

is_old_mdata <- all(so@meta.data[so$UPN == "1455",c("Dx")] == "low grade glioma FGFR mutant")
if(is_old_mdata){
  so@meta.data[so$UPN == "1455", "Dx"] <- "ganglioglioma"
  so@meta.data[so$UPN == "1455", "Dx_simple"] <-"ganglioglioma"
  so@meta.data[so$UPN == "1171", "Dx"] <- "pilocytic astrocytoma"
  so@meta.data[so$UPN == "1171", "Dx_simple"] <-"pilocytic astrocytoma"
}
```

```{r}
# Specify the UPN values to include in the plot
pa_selected_UPNs <- c("855", "897", "946", "957", "1033", "1056", "1057", "1171", "1266", "1272", "1330", "1453", "1459")

# Subset the Seurat object based on the 'UPN' metadata column
so_pa_immune <- so[, so$UPN %in% pa_selected_UPNs]

plot_harmony(so_pa_immune, "UPN")
plot_harmony(so_pa_immune, "myl_harmony_res.0.3", legend_title = "clusters") 
```

```{r}
so_pa_immune@meta.data
```

```{r}
# Change the new labels
# cluster 0 = Microglia(Comp+P2RY12+)
# cluster 1 = Myeloid-Chemokine
# cluster 5 = Myeloid-Chemokine
# cluster 2 = Microglia(P2RY12+)
# cluster 3 = Microglia(CCL3+P2RY12+)
# cluster 4 = DC-like myeloid
# cluster 10 = DC-like myeloid
# cluster 6 = NT
# cluster 7 = Myeloid-Undefined
# cluster 8 = M2(MRC1+)
# cluster 9 = Myeloid-Tumor(MAP1B+)
# cluster 11 = Hypoxia

so_pa_immune@meta.data <- so_pa_immune@meta.data %>%
  mutate(cell_type = case_when(
    myl_harmony_res.0.3 == 0 ~ "Microglia(Comp+P2RY12+)",
    myl_harmony_res.0.3 %in% c(1, 5) ~ "Myeloid-Chemokine",
    myl_harmony_res.0.3 == 2 ~ "Microglia(P2RY12+)",
    myl_harmony_res.0.3 == 3 ~ "Microglia(CCL3+P2RY12+)",
    myl_harmony_res.0.3 %in% c(4, 10) ~ "DC-like myeloid",
    myl_harmony_res.0.3 == 6 ~ "NT",
    myl_harmony_res.0.3 == 7 ~ "Myeloid-Undefined",
    myl_harmony_res.0.3 == 8 ~ "M2(MRC1+)",
    myl_harmony_res.0.3 == 9 ~ "Myeloid-Tumor(MAP1B+)",
    myl_harmony_res.0.3 == 11 ~ "Hypoxia",
    TRUE ~ NA_character_  # Default case if no match is found
  ))

so_pa_immune@meta.data
```

```{r}
plot_harmony(so_pa_immune, "cell_type", legend_title = "clusters") 
```

```{r}
library(scran)
so_pa_immune$Dx_simple <- ifelse(str_detect(so_pa_immune$Dx, "low grade glioma"),
                       "low grade glioma",
                       so_pa_immune$Dx)
# temporary fix for issue #4639
so_diet <- DietSeurat(so_pa_immune, graphs = "pca")
sce <- as.SingleCellExperiment(so_diet)
rm(so_diet)

sce$myl_harmony_res.0.3 <- droplevels(sce$myl_harmony_res.0.3)
markers.cell_type.up <- findMarkers(sce,
                                # groups = sce$myeloid_cell_type,
                                groups = sce$myl_harmony_res.0.3,
                                block = sce$orig.ident,
                                lfc = 0.5,
                                direction="up") %>%
  lapply(., as.data.frame) %>%
  map(~rownames_to_column(.x, "gene") %>%
        filter(FDR < 0.01))

# markers.cell_type.up %>% 
#   bind_rows(.id = "cluster") %>% 
#   write_tsv(file.path(mkrs_dir, "scran_myeloid_cell_type_consensus_markers.tsv"))
# 
# map(markers.cell_type.up, 
#     ~set_xlsx_class(.x, "gene", "Text")) %>% 
# openxlsx::write.xlsx(., file.path(mkrs_dir, "scran_myleoid_cell_type_consensus_markers.xlsx"),
#                      overwrite = TRUE)
```

```{r}
# Select the top 10 genes from each group and combine them into a single data frame
top_genes_df <- lapply(names(markers.cell_type.up), function(group) {
  markers.cell_type.up[[group]] %>%
    arrange(desc(summary.logFC)) %>%  # Sort by logFC in descending order
    head(10) %>%        
    mutate(group = group)    # Add a column to identify the group
}) %>%
  bind_rows() # Combine all groups into a single data frame

top_genes_df
```

```{r}
# Change the new labels
# cluster 0 = Microglia(Comp+P2RY12+)
# cluster 1 = Myeloid-Chemokine
# cluster 5 = Myeloid-Chemokine
# cluster 2 = Microglia(P2RY12+)
# cluster 3 = Microglia(CCL3+P2RY12+)
# cluster 4 = DC-like myeloid
# cluster 10 = DC-like myeloid
# cluster 6 = NT
# cluster 7 = Myeloid-Undefined
# cluster 8 = M2(MRC1+)
# cluster 9 = Myeloid-Tumor(MAP1B+)
# cluster 11 = Hypoxia


top_genes_df <- top_genes_df %>%
  mutate(cell_type = recode(group,
                            `0` = "Microglia(Comp+P2RY12+)",
                            `1` = "Myeloid-Chemokine",
                            `5` = "Myeloid-Chemokine",
                            `2` = "Microglia(P2RY12+)",
                            `3` = "Microglia(CCL3+P2RY12+)",
                            `4` = "DC-like myeloid",
                            `10` = "DC-like myeloid",
                            `6` = "NT",
                            `7` = "Myeloid-Undefined",
                            `8` = "M2(MRC1+)",
                            `9` = "Myeloid-Tumor(MAP1B+)",
                            `11` = "Hypoxia"),
         cell_type = factor(cell_type, levels = c("Microglia(Comp+P2RY12+)", "Myeloid-Chemokine", "Microglia(P2RY12+)", "Microglia(CCL3+P2RY12+)", "DC-like myeloid", "NT", "Myeloid-Undefined", "M2(MRC1+)", "Myeloid-Tumor(MAP1B+)", "Hypoxia")))

top_genes_df
```

```{r}
# Ensure the gene order matches the original order in top_genes_df
top_genes_df <- top_genes_df %>%
  mutate(gene = factor(gene, levels = unique(gene)))

logFC_midpoint <- mean(top_genes_df$summary.logFC)  # Use the mean of logFC as midpoint

# Create the dot plot
dot_plot <- ggplot(top_genes_df, aes(x = cell_type, y = gene)) +
  geom_point(aes(size = -log10(FDR), color = summary.logFC)) +
  scale_color_gradient2(low = "blue", mid = "grey", high = "red", midpoint = logFC_midpoint) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
  ) +
  labs(color = "logFC", size = "-log10(FDR)")

dot_plot

# Specify the file path
output_file <- file.path(Dot_plot, "DotPlot_TopGenes_PA_Immune_org.pdf")

ggsave(output_file, plot = dot_plot, width = 8, height = 10)
```

```{r}
# Remove Duplicates genes
# Because some clusters combined together, so only plot the biggest value to avoid duplicates.

# Ensure the gene order matches the original order in top_genes_df
top_genes_df <- top_genes_df %>%
  mutate(gene = factor(gene, levels = unique(gene)))

# Remove duplicate genes within each cell_type, keeping the row with the highest absolute logFC
top_genes_df_unique <- top_genes_df %>%
  group_by(cell_type, gene) %>%
  filter(abs(summary.logFC) == max(abs(summary.logFC))) %>%
  ungroup()

# Calculate the midpoint for logFC (based on unique genes)
logFC_midpoint <- mean(top_genes_df_unique$summary.logFC)

# Create the dot plot with unique genes
dot_plot <- ggplot(top_genes_df_unique, aes(x = cell_type, y = gene)) +
  geom_point(aes(size = -log10(FDR), color = summary.logFC)) +
  scale_color_gradient2(low = "blue", mid = "grey", high = "red", midpoint = logFC_midpoint) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
  ) +
  labs(color = "logFC", size = "-log10(FDR)")

# Display the plot
dot_plot

# Specify the output file path
output_file <- file.path(Dot_plot, "DotPlot_TopGenes_PA_Immune.pdf")

# Save the plot to a file
ggsave(output_file, plot = dot_plot, width = 8, height = 10)
```

### REACTOME Analysis

```{r}
############# REACTOME pathway #############
#####gsePathway()

library(org.Hs.eg.db)
library(clusterProfiler)

sce$myl_harmony_res.0.3 <- droplevels(sce$myl_harmony_res.0.3)
# Without filter, use all markers.
markers.cell_type.up <- findMarkers(sce, 
                                groups = sce$myl_harmony_res.0.3, 
                                # groups = sce$myeloid_cell_type, 
                                block = sce$orig.ident,
                                lfc = 0.5,
                                direction="up") %>% 
  lapply(., as.data.frame) %>%
  map(~rownames_to_column(.x, "gene"))

# Keep only the first five columns for each cluster
markers.cell_type.up <- lapply(markers.cell_type.up, function(df) {
  df[, c("gene", "Top", "p.value", "FDR", "summary.logFC")]
})

# Combine all clusters into a single data frame with the cluster information
markers.cell_type.up.df <- do.call(rbind, lapply(names(markers.cell_type.up), function(cluster) {
  cluster_markers <- markers.cell_type.up[[cluster]]
  cluster_markers$cluster <- cluster  # Add cluster information
  return(cluster_markers)
}))

# Reset row names for clarity
rownames(markers.cell_type.up.df) <- NULL

# Rank genes within each cluster based on summary.logFC (you can adjust the order if needed)
markers.cell_type.up.df <- markers.cell_type.up.df %>%
  group_by(cluster) %>%
  arrange(cluster, desc(summary.logFC)) %>%
  ungroup()

# Split the data by cluster and extract ranked gene names along with summary.logFC
cluster_gene_lists_all <- markers.cell_type.up.df %>%
  split(.$cluster) %>%
  lapply(function(x) {
    # Create a data frame with both Entrez ID and summary.logFC for each gene
    mapped_genes <- bitr(x$gene, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Hs.eg.db)
    
    # Merge the mapped Entrez ID with the summary.logFC values
    merged_data <- merge(mapped_genes, x[, c("gene", "summary.logFC")], by.x = "SYMBOL", by.y = "gene")
    
    # Sort based on summary.logFC
    merged_data <- merged_data %>%
      arrange(desc(summary.logFC))
    
    # Return a named vector with Entrez IDs as names and summary.logFC values as values
    return(setNames(merged_data$summary.logFC, merged_data$ENTREZID))
  })

# Now, you can proceed to use `cluster_gene_lists_all` for pathway analysis
library(ReactomePA)

# Reactome pathway analysis for each cluster
reactome_results_all <- lapply(cluster_gene_lists_all, function(gene_list) {
  # Perform gsePathway on each gene list (ranked by summary.logFC)
  gsePathway(geneList = gene_list, 
             pvalueCutoff = 0.2,
             pAdjustMethod = "BH", 
             verbose = FALSE)
})
```

```{r}
# Save the REACTOME results table

library(openxlsx)
library(writexl)

# Convert each result to a data frame
reactome_results_df_all <- lapply(reactome_results_all, function(result) {
  # Convert Reactome pathway results into a data frame
  as.data.frame(result)
})

# Custom sheet names mapping using the according order from reactome_results_all (number, like 0, 1, 10, 12, 2...)
custom_sheet_names <- c(
  "0" = "Microglia(Comp+P2RY12+)",
  "1" = "Myeloid-Chemokine",
  "5" = "Myeloid-Chemokine",
  "2" = "Microglia(P2RY12+)",
  "3" = "Microglia(CCL3+P2RY12+)",
  "4" = "DC-like myeloid",
  "10" = "DC-like myeloid",
  "6" = "NT",
  "7" = "Myeloid-Undefined",
  "8" = "M2(MRC1+)", 
  "9"= "Myeloid-Tumor(MAP1B+)",
  "11" = "Hypoxia"
)
         
list_order <- c(0, 1, 10, 11, 2, 3, 4, 5, 6, 7, 8, 9)
  
# Rename the elements in reactome_results_df_all according to the custom sheet names
names(reactome_results_df_all) <- custom_sheet_names[as.character(list_order)]

# For Combine
reactome_results_df_all_cb <- lapply(reactome_results_all, function(result) {
  # Convert Reactome pathway results into a data frame
  as.data.frame(result)
})

# Combine results for clusters with the same sheet name into one
combined_results <- list()

for (sheet_name in unique(custom_sheet_names[as.character(list_order)])) {
  # Find the clusters with the same sheet name
  matching_clusters <- names(reactome_results_df_all_cb)[custom_sheet_names[names(reactome_results_df_all_cb)] == sheet_name]
  
  # Combine results for these clusters (using bind_rows to combine data frames)
  combined_results[[sheet_name]] <- do.call(rbind, reactome_results_df_all_cb[matching_clusters])
}

# Specify the output file path
output_excel_file <- paste0(REACTOME_Analysis, "/PA_Immune_Reactome_Pathway_Analysis_Results.xlsx")

# Write the combined results to an Excel file, with one sheet for each unique name
write_xlsx(combined_results, path = output_excel_file)
```

```{r}
# Bubble Plot

library(ggplot2)
library(dplyr)

# Extract top 5 pathways for each cluster
top_pathways_all <- lapply(reactome_results_all, function(result) {
  if (!is.null(result) && nrow(result) > 0) {
    # Sort pathways by p-value (ascending order) and pick top 5
    top_pathways <- result %>%
      arrange(p.adjust) %>%   # Sort by adjusted p-value
      head(5)                  # Select top 5 pathways
    
    return(top_pathways)
  } else {
    return(NULL)  # In case there are no results for this cluster
  }
})

# Combine all top pathways into a single data frame for easier plotting
top_pathways_df <- do.call(rbind, lapply(names(top_pathways_all), function(cluster) {
  cluster_top_pathways <- top_pathways_all[[cluster]]
  
  if (!is.null(cluster_top_pathways)) {
    # Add the cluster information to the pathways data
    cluster_top_pathways$cluster <- cluster
    return(cluster_top_pathways)
  } else {
    return(NULL)
  }
}))

# Reset row names for clarity
rownames(top_pathways_df) <- NULL

# Change the new labels
# cluster 0 = Microglia(Comp+P2RY12+)
# cluster 1 = Myeloid-Chemokine
# cluster 5 = Myeloid-Chemokine
# cluster 2 = Microglia(P2RY12+)
# cluster 3 = Microglia(CCL3+P2RY12+)
# cluster 4 = DC-like myeloid
# cluster 10 = DC-like myeloid
# cluster 6 = NT
# cluster 7 = Myeloid-Undefined
# cluster 8 = M2(MRC1+)
# cluster 9 = Myeloid-Tumor(MAP1B+)
# cluster 11 = Hypoxia

library(dplyr)

# Create a mapping of cluster numbers to cell types
cluster_to_cell_type <- c(
  "0" = "Microglia(Comp+P2RY12+)",
  "1" = "Myeloid-Chemokine",
  "5" = "Myeloid-Chemokine",
  "2" = "Microglia(P2RY12+)",
  "3" = "Microglia(CCL3+P2RY12+)",  
  "4" = "DC-like myeloid",
  "10" = "DC-like myeloid",
  "6" = "NT",
  "7" = "Myeloid-Undefined",
  "8" = "M2(MRC1+)",    
  "9" = "Myeloid-Tumor(MAP1B+)",
  "11" = "Hypoxia"
)

# Add a 'cell_type' column to the top_pathways_df based on the cluster number
top_pathways_df <- top_pathways_df %>%
  mutate(cell_type = cluster_to_cell_type[as.character(cluster)])

# Ensure cell_type is ordered according to the desired mapping
top_pathways_df$cell_type <- factor(
  top_pathways_df$cell_type,
  levels = c(
    "Microglia(Comp+P2RY12+)",
    "Myeloid-Chemokine",
    "Microglia(P2RY12+)",
    "Microglia(CCL3+P2RY12+)",
    "DC-like myeloid",
    "NT",
    "Myeloid-Undefined",
    "M2(MRC1+)",
    "Myeloid-Tumor(MAP1B+)",
    "Hypoxia"
  )
)

# Save the updated plot as a PDF
pdf(paste0(REACTOME_Analysis, "/PA_Immune_REACTOME_Analysis_Bubble_Plot_org.pdf"), height = 6, width = 10)

# Bubble plot with cell_type on x-axis, ordered explicitly
ggplot(top_pathways_df, aes(x = cell_type, y = reorder(Description, p.adjust), size = -log10(p.adjust), color = NES)) +
  geom_point(alpha = 0.7) +
  theme_minimal() +
  scale_color_gradient(low = "blue", high = "red", name = "NES") +  # NES values as color gradient
  labs(title = "PA Immune Top Reactome Pathways",
       x = "Cell Type",
       y = "Pathway") +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 8),  # Rotate x-axis labels
    axis.text.y = element_text(size = 8),
    legend.position = "right"
  )

dev.off()


# Only keep top 5 each cluster, removing duplicates
# Combine rows with the same cell_type
combined_pathways_df <- top_pathways_df %>%
  group_by(cell_type) %>%
  arrange(cell_type, p.adjust) %>%
  slice_head(n = 5) %>%
  ungroup()

# Save the updated plot as a PDF
pdf(paste0(REACTOME_Analysis, "/PA_Immune_REACTOME_Analysis_Bubble_Plot.pdf"), height = 6, width = 10)

# Bubble plot with cell_type on x-axis, ordered explicitly
ggplot(combined_pathways_df, aes(x = cell_type, y = reorder(Description, p.adjust), size = -log10(p.adjust), color = NES)) +
  geom_point(alpha = 0.7) +
  theme_minimal() +
  scale_color_gradient(low = "blue", high = "red", name = "NES") +  # NES values as color gradient
  labs(title = "PA Immune Top Reactome Pathways",
       x = "Cell Type",
       y = "Pathway") +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 8),  # Rotate x-axis labels
    axis.text.y = element_text(size = 8),
    legend.position = "right"
  )

dev.off()
```

## GG-Immune

### Top 10 Markers Dot Plot

```{r}
set.seed(99)

so <- qread(file.path("..", "immune", "objects", "so_myeloid.qs"), nthreads = 4)

is_old_mdata <- all(so@meta.data[so$UPN == "1455",c("Dx")] == "low grade glioma FGFR mutant")
if(is_old_mdata){
  so@meta.data[so$UPN == "1455", "Dx"] <- "ganglioglioma"
  so@meta.data[so$UPN == "1455", "Dx_simple"] <-"ganglioglioma"
  so@meta.data[so$UPN == "1171", "Dx"] <- "pilocytic astrocytoma"
  so@meta.data[so$UPN == "1171", "Dx_simple"] <-"pilocytic astrocytoma"
}
```

```{r}
# Specify the UPN values to include in the plot
gg_selected_UPNs <- c("1116", "1181", "1216", "1417", "1455", "1491", "1492")

# Subset the Seurat object based on the 'UPN' metadata column
so_gg_immune <- so[, so$UPN %in% gg_selected_UPNs]

# Plot the Harmony UMAP with only the specified UPN values
plot_harmony(so_gg_immune, "UPN")
plot_harmony(so_gg_immune, "myl_harmony_res.0.3", legend_title = "clusters") 
```

```{r}
so_gg_immune@meta.data
```

```{r}
# Change the new labels
# cluster 0 = Microglia(Comp+P2RY12+)
# cluster 1 = Myeloid-Chemokine
# cluster 5 = Myeloid-Chemokine
# cluster 2 = Microglia(P2RY12+)
# cluster 3 = Microglia(CCL3+P2RY12+)
# cluster 4 = DC-like myeloid
# cluster 10 = DC-like myeloid
# cluster 6 = NT
# cluster 7 = Myeloid-Undefined
# cluster 8 = M2(MRC1+)
# cluster 9 = Myeloid-Tumor(MAP1B+)
# cluster 11 = Hypoxia

so_gg_immune@meta.data <- so_gg_immune@meta.data %>%
  mutate(cell_type = case_when(
    myl_harmony_res.0.3 == 0 ~ "Microglia(Comp+P2RY12+)",
    myl_harmony_res.0.3 %in% c(1, 5) ~ "Myeloid-Chemokine",
    myl_harmony_res.0.3 == 2 ~ "Microglia(P2RY12+)",
    myl_harmony_res.0.3 == 3 ~ "Microglia(CCL3+P2RY12+)",
    myl_harmony_res.0.3 %in% c(4, 10) ~ "DC-like myeloid",
    myl_harmony_res.0.3 == 6 ~ "NT",
    myl_harmony_res.0.3 == 7 ~ "Myeloid-Undefined",
    myl_harmony_res.0.3 == 8 ~ "M2(MRC1+)",
    myl_harmony_res.0.3 == 9 ~ "Myeloid-Tumor(MAP1B+)",
    myl_harmony_res.0.3 == 11 ~ "Hypoxia",
    TRUE ~ NA_character_  # Default case if no match is found
  ))

so_gg_immune@meta.data
```

```{r}
plot_harmony(so_gg_immune, "cell_type", legend_title = "harmony-clusters") 
```

```{r}
library(scran)
so_gg_immune$Dx_simple <- ifelse(str_detect(so_gg_immune$Dx, "low grade glioma"),
                       "low grade glioma",
                       so_gg_immune$Dx)
# temporary fix for issue #4639
so_diet <- DietSeurat(so_gg_immune, graphs = "pca")
sce <- as.SingleCellExperiment(so_diet)
rm(so_diet)

sce$myl_harmony_res.0.3 <- droplevels(sce$myl_harmony_res.0.3)
markers.cell_type.up <- findMarkers(sce,
                                groups = sce$myl_harmony_res.0.3,
                                block = sce$orig.ident,
                                lfc = 0.5,
                                direction="up") %>%
  lapply(., as.data.frame) %>%
  map(~rownames_to_column(.x, "gene") %>%
        filter(FDR < 0.01))

# markers.cell_type.up %>% 
#   bind_rows(.id = "cluster") %>% 
#   write_tsv(file.path(mkrs_dir, "scran_t_cell_type_consensus_markers.tsv"))
# 
# map(markers.cell_type.up, 
#     ~set_xlsx_class(.x, "gene", "Text")) %>% 
# openxlsx::write.xlsx(., file.path(mkrs_dir, "scran_t_cell_type_consensus_markers.xlsx"),
#                      overwrite = TRUE)
```

```{r}
# Select the top 10 genes from each group and combine them into a single data frame
top_genes_df <- lapply(names(markers.cell_type.up), function(group) {
  markers.cell_type.up[[group]] %>%
    arrange(desc(summary.logFC)) %>%  # Sort by logFC in descending order
    head(10) %>%        
    mutate(group = group)    # Add a column to identify the group
}) %>%
  bind_rows() # Combine all groups into a single data frame

top_genes_df
```

```{r}
# Change the new labels
# cluster 0 = Microglia(Comp+P2RY12+)
# cluster 1 = Myeloid-Chemokine
# cluster 5 = Myeloid-Chemokine
# cluster 2 = Microglia(P2RY12+)
# cluster 3 = Microglia(CCL3+P2RY12+)
# cluster 4 = DC-like myeloid
# cluster 10 = DC-like myeloid
# cluster 6 = NT
# cluster 7 = Myeloid-Undefined
# cluster 8 = M2(MRC1+)
# cluster 9 = Myeloid-Tumor(MAP1B+)
# cluster 11 = Hypoxia


top_genes_df <- top_genes_df %>%
  mutate(cell_type = recode(group,
                            `0` = "Microglia(Comp+P2RY12+)",
                            `1` = "Myeloid-Chemokine",
                            `5` = "Myeloid-Chemokine",
                            `2` = "Microglia(P2RY12+)",
                            `3` = "Microglia(CCL3+P2RY12+)",
                            `4` = "DC-like myeloid",
                            `10` = "DC-like myeloid",
                            `6` = "NT",
                            `7` = "Myeloid-Undefined",
                            `8` = "M2(MRC1+)",
                            `9` = "Myeloid-Tumor(MAP1B+)",
                            `11` = "Hypoxia"),
         cell_type = factor(cell_type, levels = c("Microglia(Comp+P2RY12+)", "Myeloid-Chemokine", "Microglia(P2RY12+)", "Microglia(CCL3+P2RY12+)", "DC-like myeloid", "NT", "Myeloid-Undefined", "M2(MRC1+)", "Myeloid-Tumor(MAP1B+)", "Hypoxia")))

top_genes_df
```

```{r}
# Ensure the gene order matches the original order in top_genes_df
top_genes_df <- top_genes_df %>%
  mutate(gene = factor(gene, levels = unique(gene)))

logFC_midpoint <- mean(top_genes_df$summary.logFC)  # Use the mean of logFC as midpoint

# Create the dot plot
dot_plot <- ggplot(top_genes_df, aes(x = cell_type, y = gene)) +
  geom_point(aes(size = -log10(FDR), color = summary.logFC)) +
  scale_color_gradient2(low = "blue", mid = "grey", high = "red", midpoint = logFC_midpoint) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
  ) +
  labs(color = "logFC", size = "-log10(FDR)")

dot_plot

# Specify the file path
output_file <- file.path(Dot_plot, "DotPlot_TopGenes_GG_Immune_org.pdf")

ggsave(output_file, plot = dot_plot, width = 8, height = 10)
```

```{r}
# Remove Duplicates genes
# Because some clusters combined together, so only plot the biggest value to avoid duplicates.

# Ensure the gene order matches the original order in top_genes_df
top_genes_df <- top_genes_df %>%
  mutate(gene = factor(gene, levels = unique(gene)))

# Remove duplicate genes within each cell_type, keeping the row with the highest absolute logFC
top_genes_df_unique <- top_genes_df %>%
  group_by(cell_type, gene) %>%
  filter(abs(summary.logFC) == max(abs(summary.logFC))) %>%
  ungroup()

# Calculate the midpoint for logFC (based on unique genes)
logFC_midpoint <- mean(top_genes_df_unique$summary.logFC)

# Create the dot plot with unique genes
dot_plot <- ggplot(top_genes_df_unique, aes(x = cell_type, y = gene)) +
  geom_point(aes(size = -log10(FDR), color = summary.logFC)) +
  scale_color_gradient2(low = "blue", mid = "grey", high = "red", midpoint = logFC_midpoint) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
  ) +
  labs(color = "logFC", size = "-log10(FDR)")

# Display the plot
dot_plot

# Specify the output file path
output_file <- file.path(Dot_plot, "DotPlot_TopGenes_GG_Immune.pdf")

# Save the plot to a file
ggsave(output_file, plot = dot_plot, width = 8, height = 10)
```

### REACTOME Analysis

```{r}
############# REACTOME pathway #############
#####gsePathway()

library(org.Hs.eg.db)
library(clusterProfiler)

sce$myl_harmony_res.0.3 <- droplevels(sce$myl_harmony_res.0.3)
# Without filter, use all markers.
markers.cell_type.up <- findMarkers(sce, 
                                groups = sce$myl_harmony_res.0.3, 
                                block = sce$orig.ident,
                                lfc = 0.5,
                                direction="up") %>% 
  lapply(., as.data.frame) %>%
  map(~rownames_to_column(.x, "gene"))

# Keep only the first five columns for each cluster
markers.cell_type.up <- lapply(markers.cell_type.up, function(df) {
  df[, c("gene", "Top", "p.value", "FDR", "summary.logFC")]
})

# Combine all clusters into a single data frame with the cluster information
markers.cell_type.up.df <- do.call(rbind, lapply(names(markers.cell_type.up), function(cluster) {
  cluster_markers <- markers.cell_type.up[[cluster]]
  cluster_markers$cluster <- cluster  # Add cluster information
  return(cluster_markers)
}))

# Reset row names for clarity
rownames(markers.cell_type.up.df) <- NULL

# Rank genes within each cluster based on summary.logFC (you can adjust the order if needed)
markers.cell_type.up.df <- markers.cell_type.up.df %>%
  group_by(cluster) %>%
  arrange(cluster, desc(summary.logFC)) %>%
  ungroup()

# Split the data by cluster and extract ranked gene names along with summary.logFC
cluster_gene_lists_all <- markers.cell_type.up.df %>%
  split(.$cluster) %>%
  lapply(function(x) {
    # Create a data frame with both Entrez ID and summary.logFC for each gene
    mapped_genes <- bitr(x$gene, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Hs.eg.db)
    
    # Merge the mapped Entrez ID with the summary.logFC values
    merged_data <- merge(mapped_genes, x[, c("gene", "summary.logFC")], by.x = "SYMBOL", by.y = "gene")
    
    # Sort based on summary.logFC
    merged_data <- merged_data %>%
      arrange(desc(summary.logFC))
    
    # Return a named vector with Entrez IDs as names and summary.logFC values as values
    return(setNames(merged_data$summary.logFC, merged_data$ENTREZID))
  })

# Now, you can proceed to use `cluster_gene_lists_all` for pathway analysis
library(ReactomePA)

# Reactome pathway analysis for each cluster
reactome_results_all <- lapply(cluster_gene_lists_all, function(gene_list) {
  # Perform gsePathway on each gene list (ranked by summary.logFC)
  gsePathway(geneList = gene_list, 
             pvalueCutoff = 0.2,
             pAdjustMethod = "BH", 
             verbose = FALSE)
})
```

```{r}
# Save the REACTOME results table

library(openxlsx)
library(writexl)

# Convert each result to a data frame
reactome_results_df_all <- lapply(reactome_results_all, function(result) {
  # Convert Reactome pathway results into a data frame
  as.data.frame(result)
})

# Custom sheet names mapping using the according order from reactome_results_all (number, like 0, 1, 10, 12, 2...)
custom_sheet_names <- c(
  "0" = "Microglia(Comp+P2RY12+)",
  "1" = "Myeloid-Chemokine",
  "5" = "Myeloid-Chemokine",
  "2" = "Microglia(P2RY12+)",
  "3" = "Microglia(CCL3+P2RY12+)",
  "4" = "DC-like myeloid",
  "10" = "DC-like myeloid",
  "6" = "NT",
  "7" = "Myeloid-Undefined",
  "8" = "M2(MRC1+)", 
  "9"= "Myeloid-Tumor(MAP1B+)",
  "11" = "Hypoxia"
)
         
list_order <- c(0, 1, 10, 11, 2, 3, 4, 5, 6, 7, 8, 9)
  
# Rename the elements in reactome_results_df_all according to the custom sheet names
names(reactome_results_df_all) <- custom_sheet_names[as.character(list_order)]

# For Combine
reactome_results_df_all_cb <- lapply(reactome_results_all, function(result) {
  # Convert Reactome pathway results into a data frame
  as.data.frame(result)
})

# Combine results for clusters with the same sheet name into one
combined_results <- list()

for (sheet_name in unique(custom_sheet_names[as.character(list_order)])) {
  # Find the clusters with the same sheet name
  matching_clusters <- names(reactome_results_df_all_cb)[custom_sheet_names[names(reactome_results_df_all_cb)] == sheet_name]
  
  # Combine results for these clusters (using bind_rows to combine data frames)
  combined_results[[sheet_name]] <- do.call(rbind, reactome_results_df_all_cb[matching_clusters])
}

# Specify the output file path
output_excel_file <- paste0(REACTOME_Analysis, "/GG_Immune_Reactome_Pathway_Analysis_Results.xlsx")

# Write the combined results to an Excel file, with one sheet for each unique name
write_xlsx(combined_results, path = output_excel_file)
```

```{r}
# Bubble Plot

library(ggplot2)
library(dplyr)

# Extract top 5 pathways for each cluster
top_pathways_all <- lapply(reactome_results_all, function(result) {
  if (!is.null(result) && nrow(result) > 0) {
    # Sort pathways by p-value (ascending order) and pick top 5
    top_pathways <- result %>%
      arrange(p.adjust) %>%   # Sort by adjusted p-value
      head(5)                  # Select top 5 pathways
    
    return(top_pathways)
  } else {
    return(NULL)  # In case there are no results for this cluster
  }
})

# Combine all top pathways into a single data frame for easier plotting
top_pathways_df <- do.call(rbind, lapply(names(top_pathways_all), function(cluster) {
  cluster_top_pathways <- top_pathways_all[[cluster]]
  
  if (!is.null(cluster_top_pathways)) {
    # Add the cluster information to the pathways data
    cluster_top_pathways$cluster <- cluster
    return(cluster_top_pathways)
  } else {
    return(NULL)
  }
}))

# Reset row names for clarity
rownames(top_pathways_df) <- NULL

# Change the new labels
# cluster 0 = Microglia(Comp+P2RY12+)
# cluster 1 = Myeloid-Chemokine
# cluster 5 = Myeloid-Chemokine
# cluster 2 = Microglia(P2RY12+)
# cluster 3 = Microglia(CCL3+P2RY12+)
# cluster 4 = DC-like myeloid
# cluster 10 = DC-like myeloid
# cluster 6 = NT
# cluster 7 = Myeloid-Undefined
# cluster 8 = M2(MRC1+)
# cluster 9 = Myeloid-Tumor(MAP1B+)
# cluster 11 = Hypoxia

library(dplyr)

# Create a mapping of cluster numbers to cell types
cluster_to_cell_type <- c(
  "0" = "Microglia(Comp+P2RY12+)",
  "1" = "Myeloid-Chemokine",
  "5" = "Myeloid-Chemokine",
  "2" = "Microglia(P2RY12+)",
  "3" = "Microglia(CCL3+P2RY12+)",  
  "4" = "DC-like myeloid",
  "10" = "DC-like myeloid",
  "6" = "NT",
  "7" = "Myeloid-Undefined",
  "8" = "M2(MRC1+)",    
  "9" = "Myeloid-Tumor(MAP1B+)",
  "11" = "Hypoxia"
)

# Add a 'cell_type' column to the top_pathways_df based on the cluster number
top_pathways_df <- top_pathways_df %>%
  mutate(cell_type = cluster_to_cell_type[as.character(cluster)])

# Ensure cell_type is ordered according to the desired mapping
top_pathways_df$cell_type <- factor(
  top_pathways_df$cell_type,
  levels = c(
    "Microglia(Comp+P2RY12+)",
    "Myeloid-Chemokine",
    "Microglia(P2RY12+)",
    "Microglia(CCL3+P2RY12+)",
    "DC-like myeloid",
    "NT",
    "Myeloid-Undefined",
    "M2(MRC1+)",
    "Myeloid-Tumor(MAP1B+)",
    "Hypoxia"
  )
)

# Save the updated plot as a PDF
pdf(paste0(REACTOME_Analysis, "/GG_Immune_REACTOME_Analysis_Bubble_Plot_org.pdf"), height = 6, width = 10)

# Bubble plot with cell_type on x-axis, ordered explicitly
ggplot(top_pathways_df, aes(x = cell_type, y = reorder(Description, p.adjust), size = -log10(p.adjust), color = NES)) +
  geom_point(alpha = 0.7) +
  theme_minimal() +
  scale_color_gradient(low = "blue", high = "red", name = "NES") +  # NES values as color gradient
  labs(title = "GG Immune Top Reactome Pathways",
       x = "Cell Type",
       y = "Pathway") +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 8),  # Rotate x-axis labels
    axis.text.y = element_text(size = 8),
    legend.position = "right"
  )

dev.off()


# Only keep top 5 each cluster, removing duplicates
# Combine rows with the same cell_type
combined_pathways_df <- top_pathways_df %>%
  group_by(cell_type) %>%
  arrange(cell_type, p.adjust) %>%
  slice_head(n = 5) %>%
  ungroup()

# Save the updated plot as a PDF
pdf(paste0(REACTOME_Analysis, "/GG_Immune_REACTOME_Analysis_Bubble_Plot.pdf"), height = 6, width = 10)

# Bubble plot with cell_type on x-axis, ordered explicitly
ggplot(combined_pathways_df, aes(x = cell_type, y = reorder(Description, p.adjust), size = -log10(p.adjust), color = NES)) +
  geom_point(alpha = 0.7) +
  theme_minimal() +
  scale_color_gradient(low = "blue", high = "red", name = "NES") +  # NES values as color gradient
  labs(title = "GG Immune Top Reactome Pathways",
       x = "Cell Type",
       y = "Pathway") +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 8),  # Rotate x-axis labels
    axis.text.y = element_text(size = 8),
    legend.position = "right"
  )

dev.off()
```

# Deprecated - Tian's Method

```{r}
# Load the data and modify the label:

so_pa <- qread(file.path("..", "tumor", "objects", "so_tumor_pa2.qs"))
so_pa$Dx_simple <- ifelse(str_detect(so_pa$Dx, "low grade glioma"),
                       "low grade glioma",
                       so_pa$Dx)

# Change the labels
# cluster 0 = OC-like 1
# cluster 1 = OPC-like
# cluster 2 = AC-like 1
# cluster 3 = 1459-specific
# cluster 4 = MAPKhi
# cluster 5 = AC-like 2
# cluster 6 = Hypoxic
# cluster 7 = 1171-specific
# cluster 8 = OC-like 2

table(so_pa@meta.data$pa_tumor_harmony_res.0.3)

# Define the cluster to label mapping
label_mapping <- c(
  "0" = "OC-like 1",
  "1" = "OPC-like",
  "2" = "AC-like 1",
  "3" = "1459-specific",
  "4" = "MAPKhi",
  "5" = "AC-like 2",
  "6" = "Hypoxic",
  "7" = "1171-specific",
  "8" = "OC-like 2"
)

# Add a new column 'pa_final_label' based on the cluster mapping
so_pa@meta.data$pa_final_label <- label_mapping[as.character(so_pa@meta.data$pa_tumor_harmony_res.0.3)]

table(so_pa@meta.data$pa_final_label)
```

```{r}
####### PA Tumor

library(Seurat)
library(stringr)

# so_diet <- DietSeurat(so_pa, graphs = "pca")
# sce <- so_diet
sce_pa <- so_pa
# Clean up
# rm(so_diet)

sce_pa$pa_tumor_harmony_res.0.3 <- droplevels(sce_pa$pa_tumor_harmony_res.0.3)
Idents(sce_pa) <- "pa_tumor_harmony_res.0.3"

pa_markers.cell_type = sce_pa %>%
    FindAllMarkers(.,
      # identify genes that are uniquely or predominantly expressed in each cluster compared to others
      only.pos = T,
      min.pct = 0.25, # Minimum percentage of cells expressing the gene
      logfc.threshold = 0.25 # Log-fold change threshold
    )

# Select top 10 markers per cluster based on average log2 fold-change
pa_top10_markers <- pa_markers.cell_type %>%
  group_by(cluster) %>%
  top_n(n = 10, wt = avg_log2FC)

# Extract the top markers per cluster
pa_top10_genes <- unique(pa_top10_markers$gene)

# Calculate average expression of selected top genes for each cluster
avg_expr <- AverageExpression(
  sce_pa,
  features = pa_top10_genes,
  group.by = "pa_final_label",
  # group.by = "pa_tumor_harmony_res.0.3",
  slot = "data"  # Use the "data" slot to get log-normalized values
)$RNA
  
# Subset the average expression matrix to only include selected top genes
avg_expr_subset <- avg_expr[pa_top10_genes, ]
  
# Perform row-wise z-score normalization
avg_expr_zscore <- t(scale(t(avg_expr_subset)))
  
# Define the desired order of clusters
desired_order <- c(
  "OC-like 1",
  "OPC-like",
  "AC-like 1",
  "1459-specific",
  "MAPKhi",
  "AC-like 2",
  "Hypoxic",
  "1171-specific",
  "OC-like 2"
)

avg_expr_zscore <- avg_expr_zscore[, desired_order]

heatmap_plot <- pheatmap(
  avg_expr_zscore,
  cluster_rows = T,
  cluster_cols = T,
  fontsize_row = 3,
  fontsize_col = 5,
  main = paste("PA Top 10 Markers Z-score Normalized Heatmap")
)

# Print the heatmap
print(heatmap_plot)

# avg_expr_zscore_df <- melt(avg_expr_zscore)
# 
# # Create the heatmap using ggplot2
# heatmap_plot <- ggplot(avg_expr_zscore_df, aes(x = Var2, y = Var1, fill = value)) +
#   geom_tile() +
#   scale_fill_gradient2(
#     low = "blue", high = "red", mid = "white", midpoint = 0, 
#     name = "Log-normalized Average Z-score"  # Change the legend title here
#   ) +
#   theme_minimal() +
#   theme(
#     axis.text.x = element_text(angle = 90, hjust = 1, size = 5),
#     axis.text.y = element_text(size = 3),
#     plot.title = element_text(hjust = 0.5)
#   ) +
#   labs(
#     title = "PA Top 10 Markers Z-score Normalized Heatmap",
#     x = "Sample", 
#     y = "Gene"
#   )

# # Save the heatmap plot to PDF
# ggsave(
#   filename = paste0("/Heatmap_w_harmony_res.0.3_topMarkers_Zscore.pdf"),
#   plot = heatmap_plot,
#   width = 10,
#   height = 8
# )
```

```{r}
# Make as a dot plot:

# library(ggplot2)
# library(reshape2)
# 
# # Convert the matrix to a data frame for ggplot
# avg_expr_zscore_df <- melt(avg_expr_zscore)
# 
# # Create the dot plot using ggplot2
# dot_plot <- ggplot(avg_expr_zscore_df, aes(x = Var2, y = Var1, size = value, color = value)) +
#   geom_point() +
#   scale_size(range = c(2, 10)) +  # Adjust the size range of the dots
#   scale_color_gradient2(
#     low = "blue", high = "red", mid = "white", midpoint = 0, 
#     name = "Log-normalized Average Z-score"
#   ) +
#   theme_minimal() +
#   theme(
#     axis.text.x = element_text(angle = 90, hjust = 1, size = 5),
#     axis.text.y = element_text(size = 3),
#     plot.title = element_text(hjust = 0.5)
#   ) +
#   labs(
#     title = "PA Top 10 Markers Z-score Normalized Dot Plot",
#     x = "Sample", 
#     y = "Gene"
#   )
# 
# print(dot_plot)
```

# Test: PA-Tumor (dot plot+REACTOME+ssGSEA)

```{r}
# Reference: from "tumor/pa.Rmd"
# Here use SingleCellExperiment Object

so_pa <- qread(file.path("..", "tumor", "objects", "so_tumor_pa2.qs"))

library(scran)
so_pa$Dx_simple <- ifelse(str_detect(so_pa$Dx, "low grade glioma"),
                       "low grade glioma",
                       so_pa$Dx)
# temporary fix for issue #4639
so_diet <- DietSeurat(so_pa, graphs = "pca")
sce <- as.SingleCellExperiment(so_diet)
rm(so_diet)

# sce$pa_tumor_harmony_res.0.3 <- droplevels(sce$pa_tumor_harmony_res.0.3)
# markers.cell_type.up <- findMarkers(sce,
#                                 groups = sce$pa_tumor_harmony_res.0.3,
#                                 block = sce$orig.ident, # control for batch effects or sample differences.
#                                 lfc = 0.5,
#                                 direction="up") %>%
#   lapply(., as.data.frame) %>%
#   map(~rownames_to_column(.x, "gene") %>%
#         filter(FDR < 0.01))
# 
# markers.cell_type.up %>% 
#   bind_rows(.id = "cluster") %>% 
#   write_tsv(file.path(mkrs_dir, "scran_pa_tumor_consensus_markers.tsv"))
# 
# map(markers.cell_type.up, 
#     ~set_xlsx_class(.x, "gene", "Text")) %>% 
# openxlsx::write.xlsx(., file.path(mkrs_dir, "scran_pa_tumor_consensus_markers.xlsx"),
#                      overwrite = TRUE)

sce$pa_tumor_harmony_res.0.3 <- droplevels(sce$pa_tumor_harmony_res.0.3)
markers.cell_type <- findMarkers(sce,
                                groups = sce$pa_tumor_harmony_res.0.3,
                                block = sce$orig.ident, # control for batch effects or sample differences.
                                lfc = 0.5) %>%
  lapply(., as.data.frame) %>%
  map(~rownames_to_column(.x, "gene") %>%
        filter(FDR < 0.01))

markers.cell_type %>% 
  bind_rows(.id = "cluster") %>% 
  write_tsv(file.path(mkrs_dir, "scran_pa_tumor_consensus_markers_up_and_down.tsv"))

map(markers.cell_type.up, 
    ~set_xlsx_class(.x, "gene", "Text")) %>% 
openxlsx::write.xlsx(., file.path(mkrs_dir, "scran_pa_tumor_consensus_markers_up_and_down.tsv"),
                     overwrite = TRUE)
```

```{r}
# Load the data and modify the label:

so_pa <- qread(file.path("..", "tumor", "objects", "so_tumor_pa2.qs"))
so_pa$Dx_simple <- ifelse(str_detect(so_pa$Dx, "low grade glioma"),
                       "low grade glioma",
                       so_pa$Dx)

# Change the labels
# cluster 0 = OC-like 1
# cluster 1 = OPC-like
# cluster 2 = AC-like 1
# cluster 3 = 1459-specific
# cluster 4 = MAPKhi
# cluster 5 = AC-like 2
# cluster 6 = Hypoxic
# cluster 7 = 1171-specific
# cluster 8 = OC-like 2

table(so_pa@meta.data$pa_tumor_harmony_res.0.3)

# Define the cluster to label mapping
label_mapping <- c(
  "0" = "OC-like 1",
  "1" = "OPC-like",
  "2" = "AC-like 1",
  "3" = "1459-specific",
  "4" = "MAPKhi",
  "5" = "AC-like 2",
  "6" = "Hypoxic",
  "7" = "1171-specific",
  "8" = "OC-like 2"
)

# Add a new column 'pa_final_label' based on the cluster mapping
so_pa@meta.data$pa_final_label <- label_mapping[as.character(so_pa@meta.data$pa_tumor_harmony_res.0.3)]

table(so_pa@meta.data$pa_final_label)
```

```{r}
####### PA Tumor

library(Seurat)
library(stringr)

# so_diet <- DietSeurat(so_pa, graphs = "pca")
# sce <- so_diet
sce_pa <- so_pa
# Clean up
# rm(so_diet)

sce_pa$pa_tumor_harmony_res.0.3 <- droplevels(sce_pa$pa_tumor_harmony_res.0.3)
Idents(sce_pa) <- "pa_tumor_harmony_res.0.3"

pa_markers.cell_type = sce_pa %>%
    FindAllMarkers(.,
      # identify genes that are uniquely or predominantly expressed in each cluster compared to others
      only.pos = T,
      min.pct = 0.25, # Minimum percentage of cells expressing the gene
      logfc.threshold = 0.25 # Log-fold change threshold
    )

# Select top 10 markers per cluster based on average log2 fold-change
pa_top10_markers <- pa_markers.cell_type %>%
  group_by(cluster) %>%
  top_n(n = 10, wt = avg_log2FC)

# Extract the top markers per cluster
pa_top10_genes <- unique(pa_top10_markers$gene)

# Calculate average expression of selected top genes for each cluster
avg_expr <- AverageExpression(
  sce_pa,
  features = pa_top10_genes,
  group.by = "pa_final_label",
  # group.by = "pa_tumor_harmony_res.0.3",
  slot = "data"  # Use the "data" slot to get log-normalized values
)$RNA
  
# Subset the average expression matrix to only include selected top genes
avg_expr_subset <- avg_expr[pa_top10_genes, ]
  
# Perform row-wise z-score normalization
avg_expr_zscore <- t(scale(t(avg_expr_subset)))
  
# Define the desired order of clusters
desired_order <- c(
  "OC-like 1",
  "OPC-like",
  "AC-like 1",
  "1459-specific",
  "MAPKhi",
  "AC-like 2",
  "Hypoxic",
  "1171-specific",
  "OC-like 2"
)

avg_expr_zscore <- avg_expr_zscore[, desired_order]

heatmap_plot <- pheatmap(
  avg_expr_zscore,
  cluster_rows = T,
  cluster_cols = T,
  fontsize_row = 3,
  fontsize_col = 5,
  main = paste("PA Top 10 Markers Z-score Normalized Heatmap")
)

# Print the heatmap
print(heatmap_plot)

# avg_expr_zscore_df <- melt(avg_expr_zscore)
# 
# # Create the heatmap using ggplot2
# heatmap_plot <- ggplot(avg_expr_zscore_df, aes(x = Var2, y = Var1, fill = value)) +
#   geom_tile() +
#   scale_fill_gradient2(
#     low = "blue", high = "red", mid = "white", midpoint = 0, 
#     name = "Log-normalized Average Z-score"  # Change the legend title here
#   ) +
#   theme_minimal() +
#   theme(
#     axis.text.x = element_text(angle = 90, hjust = 1, size = 5),
#     axis.text.y = element_text(size = 3),
#     plot.title = element_text(hjust = 0.5)
#   ) +
#   labs(
#     title = "PA Top 10 Markers Z-score Normalized Heatmap",
#     x = "Sample", 
#     y = "Gene"
#   )

# # Save the heatmap plot to PDF
# ggsave(
#   filename = paste0("/Heatmap_w_harmony_res.0.3_topMarkers_Zscore.pdf"),
#   plot = heatmap_plot,
#   width = 10,
#   height = 8
# )
```

```{r}
# Make as a dot plot:

# library(ggplot2)
# library(reshape2)
# 
# # Convert the matrix to a data frame for ggplot
# avg_expr_zscore_df <- melt(avg_expr_zscore)
# 
# # Create the dot plot using ggplot2
# dot_plot <- ggplot(avg_expr_zscore_df, aes(x = Var2, y = Var1, size = value, color = value)) +
#   geom_point() +
#   scale_size(range = c(2, 10)) +  # Adjust the size range of the dots
#   scale_color_gradient2(
#     low = "blue", high = "red", mid = "white", midpoint = 0, 
#     name = "Log-normalized Average Z-score"
#   ) +
#   theme_minimal() +
#   theme(
#     axis.text.x = element_text(angle = 90, hjust = 1, size = 5),
#     axis.text.y = element_text(size = 3),
#     plot.title = element_text(hjust = 0.5)
#   ) +
#   labs(
#     title = "PA Top 10 Markers Z-score Normalized Dot Plot",
#     x = "Sample", 
#     y = "Gene"
#   )
# 
# print(dot_plot)
```

```{r}
############# REACTOME pathway #############
#####enrichPathway()

# Split top markers by cluster
pa_top200_markers <- pa_markers.cell_type %>%
  group_by(cluster) %>%
  top_n(n = 200, wt = avg_log2FC)

cluster_gene_lists <- pa_top200_markers %>%
  split(.$cluster) %>%
  lapply(function(x) x$gene) # Extract only gene names

library(org.Hs.eg.db)
library(clusterProfiler)

# Map gene symbols to Entrez IDs
entrez_lists <- lapply(cluster_gene_lists, function(genes) {
  bitr(genes, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Hs.eg.db) %>%
    pull(ENTREZID) %>% 
    unique()  # Get unique Entrez IDs
})

library(ReactomePA)
# Reactome pathway analysis for each cluster
reactome_results <- lapply(entrez_lists, function(entrez_ids) {
  enrichPathway(gene = entrez_ids, 
                organism = "human", 
                pvalueCutoff = 0.05, 
                qvalueCutoff = 0.05,
                readable=TRUE)
})

reactome_results_ENTREZID <- lapply(entrez_lists, function(entrez_ids) {
  enrichPathway(gene = entrez_ids, 
                organism = "human", 
                pvalueCutoff = 0.05, 
                qvalueCutoff = 0.05)
})

# # Inspect results for a specific cluster (e.g., cluster 0)
# head(reactome_results[[1]]@result)

# Extract top 5 pathways per cluster
top_pathways <- lapply(reactome_results, function(result) {
  result@result %>%
    filter(p.adjust < 0.05) %>%
    arrange(p.adjust) %>%
    head(5)  # Top 5 pathways
})

# Not the same number of top pathways
# Convert to a data frame for easy inspection
top_pathways_df <- do.call(rbind, lapply(names(top_pathways), function(cluster) {
  pathways <- top_pathways[[cluster]]
  pathways$cluster <- cluster
  pathways
}))

write.csv(top_pathways_df, "pa_top_5_pathways_each_cluster_df.csv", row.names = FALSE)


viewPathway("Cholesterol biosynthesis", 
            readable = TRUE, 
            foldChange = reactome_results_ENTREZID)
```

```{r}
############# REACTOME pathway #############
#####gsePathway()

cluster_gene_lists_all <- pa_markers.cell_type %>%
  split(.$cluster) %>%
  lapply(function(x) x$gene) # Extract only gene names

# Map gene symbols to Entrez IDs
entrez_lists_all <- lapply(cluster_gene_lists_all, function(genes) {
  bitr(genes, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Hs.eg.db) %>%
    pull(ENTREZID) %>% 
    unique()  # Get unique Entrez IDs
})

# Reactome pathway analysis for each cluster
reactome_results_all <- gsePathway(entrez_lists_all, 
                pvalueCutoff = 0.2,
                pAdjustMethod = "BH", 
                verbose = FALSE)




data(geneList, package="DOSE")
```

```{r}
# ssGSEA to compare pathway scores
library(GSVA)

# Create a list of gene sets for top pathways
pathway_gene_sets <- lapply(top_pathways, function(pathway_df) {
  # Split each 'geneID' entry by the forward slash ("/") and unlist to get a vector of gene IDs
  reactome_pathway_genes <- unlist(strsplit(pathway_df$geneID, "/"))
  # Return unique gene identifiers to avoid duplicates
  return(unique(reactome_pathway_genes))
})

# Calculate ssGSEA scores
expr_data <- as.matrix(GetAssayData(sce, slot = "data"))
ssgsea_scores <- gsva(expr_data, pathway_gene_sets, method = "ssgsea")

# Add ssGSEA scores to Seurat object metadata
sce_pa <- AddMetaData(sce_pa, as.data.frame(t(ssgsea_scores)))






# Prepare gene sets for ssGSEA
pathway_gene_sets <- lapply(names(top_pathways), function(pathway_name) {
  pathway_df <- top_pathways[[pathway_name]]
  reactome_pathway_genes <- unlist(strsplit(pathway_df$geneID, "/"))
  unique(reactome_pathway_genes)
})
names(pathway_gene_sets) <- names(top_pathways)  # Assign pathway names to the gene sets

# Get expression data from Seurat object (ensure it's normalized)
expr_data <- as.matrix(GetAssayData(sce, slot = "data"))

# Run ssGSEA to get pathway scores
# ssgsea_scores <- gsva(expr_data, pathway_gene_sets, method = "ssgsea")
ssgsea_scores <- gsva(
  expr_data,  # Expression data
  gset.idx.list = pathway_gene_sets,  # Gene sets (list of pathways)
  method = "ssgsea",  # Method for ssGSEA
  kcdf = "Gaussian",  # Type of kernel to use
  abs.ranking = TRUE  # Whether to use absolute ranking (recommended for ssGSEA)
)

# View ssGSEA results
head(ssgsea_scores)



library(Seurat)
# Example of violin plot for a pathway score
VlnPlot(sce_pa, features = colnames(ssgsea_scores)[1:5], group.by = "pa_tumor_harmony_res.0.3", pt.size = 0)

```

# Deprecated - Try UMAP in Figure 2-A of the Paper

```{r}
table(pa_res$source)
 # AC-like-1                 AC-like-2                       CD4                       CD8 
 #                      534                       133                       168                        63 
 #                  CD8_TH1         Chemokine (CCL3+)           DC-like myeloid                       gdT 
 #                      143                       341                       379                       127 
 #            Glycolysis_hi                M2 (MRC1+) Microglia (CCL3+ P2R712+) Microglia (Comp+ P2R712+) 
 #                     1072                       332                       481                       497 
 #      Microglia (P2R712+)           Myeloid (CCL3+)   Myeloid-Neuron (MAP1B+)               Neuron-like 
 #                      374                       466                       206                        21 
 #                       NK                       NKT                        Nt                   OC-like 
 #                      116                         0                       378                         0 
 #                 OPC-like               Ribosome_hi                      Treg                 CD8_dying 
 #                      776                       210                        36                        54 
 #                  Hypoxia 
 #                       33 

table(gg_res$source)
#  AC-like-1                 AC-like-2                       CD4                       CD8 
#                       711                      1849                       380                        55 
#                 CD8_dying                   CD8_TH1         Chemokine (CCL3+)           DC-like myeloid 
#                        25                       253                       202                       712 
#                       gdT                M2 (MRC1+)                    MAPKhi Microglia (CCL3+ P2R712+) 
#                       108                       725                       758                      1515 
# Microglia (Comp+ P2R712+)       Microglia (P2R712+)           Myeloid (CCL3+)   Myeloid-Neuron (MAP1B+) 
#                       739                       764                      1460                         0 
#                        NK                        Nt                 OC-like-1                 OC-like-2 
#                         0                       580                      1290                      2035 
#                  OPC-like             1171-specific                   Hypoxia                   Hypoxic 
#                      2534                       359                       237                      1393 
#                      Treg                       NKT             1459-specific 
#                         0                         0                       306 
```

```{r}
keep_cells <- rownames(pa_annots)
pa_filtered <- subset(pa, cells = keep_cells)

DimPlot(pa_filtered, reduction = "harmony_umap") + ggtitle("PA Dataset UMAP")
```

```{r}
harmony_umap_results <- Embeddings(pa_filtered, reduction = "harmony_umap")
# harmony_umap_results <- Embeddings(pa_filtered, reduction = "harmony")

harmony_umap_df <- as.data.frame(harmony_umap_results)

combined_data <- merge(harmony_umap_df, pa_annots, by = "row.names", all.x = TRUE)

colnames(combined_data)[1] <- "Cell_ID"
rownames(combined_data) <- combined_data$Cell_ID
combined_data <- combined_data[, -1]
combined_data <- combined_data[, -3]
combined_data <- combined_data[, -4]

head(combined_data)
```

```{r}
library(ggplot2)

# Create a UMAP plot with clustering by subpopulation
ggplot(combined_data, aes(x = harmonyumap_1, y = harmonyumap_2, color = subpopulation)) +
# ggplot(combined_data, aes(x = harmony_1, y = harmony_2, color = subpopulation)) +
  geom_point(alpha = 0.8) +
  labs(title = "UMAP clustering by subpopulation", x = "UMAP 1", y = "UMAP 2") +
  theme_minimal() +
  theme(legend.title = element_text(size = 10), legend.text = element_text(size = 8))

```

```{r}
keep_cells_gg <- rownames(gg_annots)
gg_filtered <- subset(gg, cells = keep_cells_gg)

DimPlot(gg_filtered, reduction = "harmony_umap") + ggtitle("GG Dataset UMAP")
```

```{r}
harmony_umap_results_gg <- Embeddings(gg_filtered, reduction = "harmony_umap")
harmony_umap_df_gg <- as.data.frame(harmony_umap_results_gg)

combined_data_gg <- merge(harmony_umap_df_gg, gg_annots, by = "row.names", all.x = TRUE)

colnames(combined_data_gg)[1] <- "Cell_ID"
rownames(combined_data_gg) <- combined_data_gg$Cell_ID
combined_data_gg <- combined_data_gg[, -1]
combined_data_gg <- combined_data_gg[, -3]
combined_data_gg <- combined_data_gg[, -4]

head(combined_data_gg)
```

```{r}
library(ggplot2)

# Create a UMAP plot with clustering by subpopulation
ggplot(combined_data_gg, aes(x = harmonyumap_1, y = harmonyumap_2, color = subpopulation)) +
  geom_point(alpha = 0.8) +
  labs(title = "UMAP clustering by subpopulation", x = "UMAP 1", y = "UMAP 2") +
  theme_minimal() +
  theme(legend.title = element_text(size = 10), legend.text = element_text(size = 8))

```

# Session info  

```{r}
sessionInfo()
```